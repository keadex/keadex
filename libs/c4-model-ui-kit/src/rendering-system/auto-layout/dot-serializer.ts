import { longerString, pxToInch, pxToPt } from '@keadex/keadex-utils'
import {
  boundaryDiagramElement,
  componentDiagramElement,
  containerDiagramElement,
  deploymentNodeDiagramElement,
  personDiagramElement,
  relationshipDiagramElement,
  softwareSystemDiagramElement,
} from '../../helper/diagram-helper'
import { generateSubgraphMarginHackId } from '../../helper/graphviz-helper'
import { Boundary } from '../../models/autogenerated/Boundary'
import { Component } from '../../models/autogenerated/Component'
import { Container } from '../../models/autogenerated/Container'
import { DeploymentNode } from '../../models/autogenerated/DeploymentNode'
import { DiagramElementType } from '../../models/autogenerated/DiagramElementType'
import { DiagramOrientation } from '../../models/autogenerated/DiagramOrientation'
import { Person } from '../../models/autogenerated/Person'
import { Point } from '../../models/autogenerated/Point'
import { Relationship } from '../../models/autogenerated/Relationship'
import { SoftwareSystem } from '../../models/autogenerated/SoftwareSystem'
import {
  BASE_ELASTIC_CONTAINER,
  BOX,
  DB,
  ELEMENT,
  PERSON,
  QUEUE,
  RELATIONSHIP,
} from '../../styles/style-constants'

export const GRAPHVIZ_DPI = 96.0

// When there is at least one subgraph, graphviz adds by default a pad. The following value has been
// manually retrieved since it is not documented.
export const GRAPHVIZ_DEFAULT_SUBGRAPH_PAD = 0.1
export const X_PAD = pxToInch(ELEMENT.SIZES.DEFAULT_LEFT)
export const Y_PAD = pxToInch(ELEMENT.SIZES.DEFAULT_TOP)

export const PERIPHERIES = 2 // hack to add a space between nodes
export const PENWIDTH = 1 // It represents the width of the borders, in points

function fromElasticContainerSizesToGraphvizSizes(): {
  margin: number
  fakeFontSize: string
} {
  const margin = pxToPt(BASE_ELASTIC_CONTAINER.SIZES.PADDING_BOX) - PENWIDTH

  // This value has been hardcoded since there are not ways to retrieve it dynamically from graphviz.
  // This value has been manually retrieved to add a fake "margin bottom" to the graphviz subgraph
  // and match the footer height (BASE_ELASTIC_CONTAINER.SIZES.FOOTER_HEIGHT) which is 23.6px
  const fakeFontSize = '17pt'
  return {
    margin,
    fakeFontSize,
  }
}

function getNodeSizeFromElementType(elementType: DiagramElementType): Point {
  const defaultSize: Point = { x: 100.0, y: 100.0 }
  const personSize: Point = {
    x: BOX.SIZES.WIDTH,
    y: BOX.SIZES.MIN_HEIGHT + PERSON.SIZES.HEAD_RADIUS * 2.0,
  }
  const boxSize: Point = { x: BOX.SIZES.WIDTH, y: BOX.SIZES.MIN_HEIGHT }
  const queueSize: Point = {
    x: BOX.SIZES.WIDTH + QUEUE.SIZES.WIDTH_TAIL + QUEUE.SIZES.WIDTH_HEAD,
    y: BOX.SIZES.MIN_HEIGHT,
  }
  const dbSize: Point = {
    x: BOX.SIZES.WIDTH,
    y: BOX.SIZES.MIN_HEIGHT + DB.SIZES.WIDTH_TOP + DB.SIZES.WIDTH_BOTTOM,
  }

  // "Include" and "Comment" elements are ignored since they are not added in the graph.
  // "Relationship" elements are ignored since they are added as edges.
  // "Boundary" and "Deployment Node" elements are ignored since they are elastic containers
  // and their size is configured with the "inner subgraph margin hack".
  // Check the "serializeSubgraph" function.
  if (personDiagramElement(elementType)) {
    return personSize
  } else if (softwareSystemDiagramElement(elementType)) {
    const system = softwareSystemDiagramElement(elementType) as SoftwareSystem
    if (
      system.system_type === 'SystemDb' ||
      system.system_type === 'SystemDb_Ext'
    ) {
      return dbSize
    } else if (
      system.system_type === 'SystemQueue' ||
      system.system_type === 'SystemQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else if (containerDiagramElement(elementType)) {
    const container = containerDiagramElement(elementType) as Container
    if (
      container.container_type === 'ContainerDb' ||
      container.container_type === 'ContainerDb_Ext'
    ) {
      return dbSize
    } else if (
      container.container_type === 'ContainerQueue' ||
      container.container_type === 'ContainerQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else if (componentDiagramElement(elementType)) {
    const component = componentDiagramElement(elementType) as Component
    if (
      component.component_type === 'ComponentDb' ||
      component.component_type === 'ComponentDb_Ext'
    ) {
      return dbSize
    } else if (
      component.component_type === 'ComponentQueue' ||
      component.component_type === 'ComponentQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else {
    return defaultSize
  }
}

function serializeSubgraph(
  alias: string,
  diagramElements: DiagramElementType[],
): string {
  const sizes = fromElasticContainerSizesToGraphvizSizes()
  return `
    subgraph "${alias}" {
        cluster=true
        margin="${sizes.margin}"
        fontsize="0pt"
        label=""
        "${alias}" [peripheries=0, height=0, width=0, label=""] // invisible node that is used as a workaround to let the connection between nodes and subgraphs
        subgraph "${generateSubgraphMarginHackId(alias)}" {
            cluster=true
            margin=0
            label=" "
            labelloc="b"
            fontsize="${sizes.fakeFontSize}"
            ${serializeGraph(diagramElements)}
        }
    }
  `
}

function serializeGraph(diagramElements: DiagramElementType[]): string {
  let graph = ''
  for (const element of diagramElements) {
    const size = getNodeSizeFromElementType(element)
    let alias
    if (personDiagramElement(element)) {
      alias = (personDiagramElement(element) as Person).base_data.alias
    } else if (softwareSystemDiagramElement(element)) {
      alias = (softwareSystemDiagramElement(element) as SoftwareSystem)
        .base_data.alias
    } else if (containerDiagramElement(element)) {
      alias = (containerDiagramElement(element) as Container).base_data.alias
    } else if (componentDiagramElement(element)) {
      alias = (componentDiagramElement(element) as Component).base_data.alias
    } else if (boundaryDiagramElement(element)) {
      const boundary = boundaryDiagramElement(element) as Boundary
      alias = boundary.base_data.alias
      if (alias)
        graph = graph.concat(serializeSubgraph(alias, boundary.sub_elements))
      alias = undefined
    } else if (deploymentNodeDiagramElement(element)) {
      const deploymentNode = deploymentNodeDiagramElement(
        element,
      ) as DeploymentNode
      alias = deploymentNode.base_data.alias
      if (alias)
        graph = graph.concat(
          serializeSubgraph(alias, deploymentNode.sub_elements),
        )
      alias = undefined
    } else if (relationshipDiagramElement(element)) {
      const relationship = relationshipDiagramElement(element) as Relationship
      graph = graph.concat(
        `\n"${relationship.from}" -> "${relationship.to}" [name="${
          relationship.base_data.alias
        }", label="${longerString([
          relationship.base_data.label ?? '',
          relationship.technology ?? '',
        ])}", ltail="${relationship.from}", lhead="${
          relationship.to
        }", fontsize="${RELATIONSHIP.FONT.SIZE_LABEL}"]`,
      )
      alias = undefined
    }
    if (alias) {
      graph = graph.concat(
        `\n"${alias}" [width=${pxToInch(
          size.x,
          GRAPHVIZ_DPI,
        )}, height=${pxToInch(
          size.y,
          GRAPHVIZ_DPI,
        )}, peripheries=${PERIPHERIES}]`,
      )
    }
  }
  return graph
}

export function serializeToGraphvizDotCode(
  diagramElements: DiagramElementType[],
  diagramOrientation: DiagramOrientation,
  pad: Point,
): string {
  return `
    digraph G {
      pad = "${pad.x},${pad.y}"
      dpi = ${GRAPHVIZ_DPI.toFixed(1)}
      penwidth="${PENWIDTH}"
      rankdir = ${diagramOrientation === 'LeftToRight' ? 'LR' : 'TB'}
      nodesep=0
      compound=true
      bgcolor="red"
      node [shape="rect", fixedsize=true, penwidth="${PENWIDTH}"]
      ${serializeGraph(diagramElements)}
    }
  `
}
