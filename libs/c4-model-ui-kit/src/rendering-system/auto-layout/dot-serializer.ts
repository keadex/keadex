import { longerString, pxToInch } from '@keadex/keadex-utils'
import {
  boundaryDiagramElement,
  componentDiagramElement,
  containerDiagramElement,
  deploymentNodeDiagramElement,
  personDiagramElement,
  relationshipDiagramElement,
  softwareSystemDiagramElement,
} from '../../helper/diagram-helper'
import { generateSubgraphMarginHackId } from '../../helper/graphviz-helper'
import { Boundary } from '../../models/autogenerated/Boundary'
import { Component } from '../../models/autogenerated/Component'
import { Container } from '../../models/autogenerated/Container'
import { DeploymentNode } from '../../models/autogenerated/DeploymentNode'
import { DiagramElementType } from '../../models/autogenerated/DiagramElementType'
import { DiagramOrientation } from '../../models/autogenerated/DiagramOrientation'
import { Person } from '../../models/autogenerated/Person'
import { Point } from '../../models/autogenerated/Point'
import { Relationship } from '../../models/autogenerated/Relationship'
import { SoftwareSystem } from '../../models/autogenerated/SoftwareSystem'
import {
  BOX,
  DB,
  ELEMENT,
  PERSON,
  QUEUE,
  RELATIONSHIP,
} from '../../styles/style-constants'

export const GRAPHVIZ_DPI = 96.0

export const X_PAD = pxToInch(ELEMENT.SIZES.DEFAULT_LEFT)
export const Y_PAD = pxToInch(ELEMENT.SIZES.DEFAULT_TOP)

export const PERIPHERIES = 2 // hack to add a space between nodes
export const PERIPHERY_SIZE = (PERIPHERIES - 1) * 4.5 // This value has been hardcoded since there are not ways to retrieve it dynamically from graphviz.
export const PENWIDTH = 1 // It represents the width of the borders, in points

// When there is at least one subgraph, graphviz adds by default a pad. The following value has been
// manually retrieved since it is not documented.
export const DEFAULT_GRAPHVIZ_SUBGRAPH_PAD = 0.1
// 6.5 = pxToPt(BASE_ELASTIC_CONTAINER.SIZES.PADDING_BOX) - PENWIDTH
// I need to hardcode this value since the same has to be hardcoded on Rust side.
export const DEFAULT_SUBGRAPH_OUTER_MARGIN = 6.5
export const DEFAULT_SUBGRAPH_INNER_MARGIN = 0
// This value has been hardcoded since there are not ways to retrieve it dynamically from graphviz.
// This value has been manually retrieved to add a fake "margin bottom" to the graphviz subgraph
// and match the footer height (BASE_ELASTIC_CONTAINER.SIZES.FOOTER_HEIGHT) which is 23.6px
export const DEFAULT_SUBGRAPH_FAKE_FONT_SIZE = '17pt'

function getNodeSizeFromElementType(elementType: DiagramElementType): Point {
  const defaultSize: Point = { x: 100.0, y: 100.0 }
  const personSize: Point = {
    x: BOX.SIZES.WIDTH,
    y: BOX.SIZES.MIN_HEIGHT + PERSON.SIZES.HEAD_RADIUS * 2.0,
  }
  const boxSize: Point = { x: BOX.SIZES.WIDTH, y: BOX.SIZES.MIN_HEIGHT }
  const queueSize: Point = {
    x: BOX.SIZES.WIDTH + QUEUE.SIZES.WIDTH_TAIL + QUEUE.SIZES.WIDTH_HEAD,
    y: BOX.SIZES.MIN_HEIGHT,
  }
  const dbSize: Point = {
    x: BOX.SIZES.WIDTH,
    y: BOX.SIZES.MIN_HEIGHT + DB.SIZES.WIDTH_TOP + DB.SIZES.WIDTH_BOTTOM,
  }

  // "Include" and "Comment" elements are ignored since they are not added in the graph.
  // "Relationship" elements are ignored since they are added as edges.
  // "Boundary" and "Deployment Node" elements are ignored since they are elastic containers
  // and their size is configured with the "inner subgraph margin hack".
  // Check the "serializeSubgraph" function.
  if (personDiagramElement(elementType)) {
    return personSize
  } else if (softwareSystemDiagramElement(elementType)) {
    const system = softwareSystemDiagramElement(elementType) as SoftwareSystem
    if (
      system.system_type === 'SystemDb' ||
      system.system_type === 'SystemDb_Ext'
    ) {
      return dbSize
    } else if (
      system.system_type === 'SystemQueue' ||
      system.system_type === 'SystemQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else if (containerDiagramElement(elementType)) {
    const container = containerDiagramElement(elementType) as Container
    if (
      container.container_type === 'ContainerDb' ||
      container.container_type === 'ContainerDb_Ext'
    ) {
      return dbSize
    } else if (
      container.container_type === 'ContainerQueue' ||
      container.container_type === 'ContainerQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else if (componentDiagramElement(elementType)) {
    const component = componentDiagramElement(elementType) as Component
    if (
      component.component_type === 'ComponentDb' ||
      component.component_type === 'ComponentDb_Ext'
    ) {
      return dbSize
    } else if (
      component.component_type === 'ComponentQueue' ||
      component.component_type === 'ComponentQueue_Ext'
    ) {
      return queueSize
    } else {
      return boxSize
    }
  } else {
    return defaultSize
  }
}

function serializeSubgraph(
  alias: string,
  diagramElements: DiagramElementType[],
  subgraphAliases: Set<string>,
  subgraphInnerMargin: number,
  subgraphOuterMargin: number,
): string {
  return `
    subgraph "${generateSubgraphMarginHackId(alias)}" {
        cluster=true
        margin="${subgraphOuterMargin}"
        fontsize="0pt"
        label=""
        subgraph "${alias}" {
            cluster=true
            margin="${subgraphInnerMargin}"
            label=" "
            labelloc="b"
            fontsize="${DEFAULT_SUBGRAPH_FAKE_FONT_SIZE}"
            "${alias}" [peripheries=0, height=0, width=0, label=""] // invisible node that is used as a workaround to let the connection between nodes and subgraphs
            ${serializeGraph(
              diagramElements,
              subgraphAliases,
              subgraphInnerMargin,
              subgraphOuterMargin,
            )}
        }
    }
  `
}

function serializeGraph(
  diagramElements: DiagramElementType[],
  subgraphAliases: Set<string>,
  subgraphInnerMargin: number,
  subgraphOuterMargin: number,
): string {
  let graph = ''
  for (const element of diagramElements) {
    const size = getNodeSizeFromElementType(element)
    let alias
    if (personDiagramElement(element)) {
      alias = (personDiagramElement(element) as Person).base_data.alias
    } else if (softwareSystemDiagramElement(element)) {
      alias = (softwareSystemDiagramElement(element) as SoftwareSystem)
        .base_data.alias
    } else if (containerDiagramElement(element)) {
      alias = (containerDiagramElement(element) as Container).base_data.alias
    } else if (componentDiagramElement(element)) {
      alias = (componentDiagramElement(element) as Component).base_data.alias
    } else if (boundaryDiagramElement(element)) {
      const boundary = boundaryDiagramElement(element) as Boundary
      alias = boundary.base_data.alias
      if (alias) {
        subgraphAliases.add(alias)
        graph = graph.concat(
          serializeSubgraph(
            alias,
            boundary.sub_elements,
            subgraphAliases,
            subgraphInnerMargin,
            subgraphOuterMargin,
          ),
        )
      }
      alias = undefined
    } else if (deploymentNodeDiagramElement(element)) {
      const deploymentNode = deploymentNodeDiagramElement(
        element,
      ) as DeploymentNode
      alias = deploymentNode.base_data.alias
      if (alias) {
        subgraphAliases.add(alias)
        graph = graph.concat(
          serializeSubgraph(
            alias,
            deploymentNode.sub_elements,
            subgraphAliases,
            subgraphInnerMargin,
            subgraphOuterMargin,
          ),
        )
      }
      alias = undefined
    } else if (relationshipDiagramElement(element)) {
      const relationship = relationshipDiagramElement(element) as Relationship
      if (relationship.from && relationship.to) {
        graph = graph.concat(
          `\n"${relationship.from}" -> "${relationship.to}" [name="${
            relationship.base_data.alias
          }", xlabel="${longerString([
            relationship.base_data.label ?? '',
            relationship.technology ?? '',
          ])}", ltail="${relationship.from}", lhead="${
            relationship.to
          }", fontsize="${
            RELATIONSHIP.FONT.SIZE_LABEL
          }", keadex_fromissubgraph=${subgraphAliases.has(
            relationship.from,
          )}, keadex_toissubgraph=${subgraphAliases.has(relationship.to)}]`,
        )
      }
      alias = undefined
    }
    if (alias) {
      graph = graph.concat(
        `\n"${alias}" [width=${pxToInch(
          size.x,
          GRAPHVIZ_DPI,
        )}, height=${pxToInch(
          size.y,
          GRAPHVIZ_DPI,
        )}, peripheries=${PERIPHERIES}]`,
      )
    }
  }
  return graph
}

export function serializeToGraphvizDotCode(
  diagramElements: DiagramElementType[],
  diagramOrientation: DiagramOrientation,
  ranksep: number,
  subgraphInnerMargin: number,
  subgraphOuterMargin: number,
  onlyStraightArrows: boolean,
  pad: Point,
): string {
  const subgraphAliases = new Set<string>()
  return `
    digraph G {
      pad = "${pad.x},${pad.y}"
      dpi = ${GRAPHVIZ_DPI.toFixed(1)}
      penwidth="${PENWIDTH}"
      rankdir = ${diagramOrientation === 'LeftToRight' ? 'LR' : 'TB'}
      nodesep=0
      ranksep=${ranksep}
      compound=true
      bgcolor="red"
      ${onlyStraightArrows ? 'splines=ortho' : ''}
      node [shape="rect", fixedsize=true, penwidth="${PENWIDTH}"]
      ${serializeGraph(
        diagramElements,
        subgraphAliases,
        subgraphInnerMargin,
        subgraphOuterMargin,
      )}
    }
  `
}
