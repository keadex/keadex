import { Graphviz } from '@hpcc-js/wasm-graphviz'
import {
  getGraphHeightInPtFromBB,
  getPadInInch,
  graphvizCoordinatesToPx,
  isSubgraphInvisibleNodeHack,
  isSubgraphMarginHack,
  svgPathFromGraphvizPos,
} from '../../helper/graphviz-helper'
import { Diagram } from '../../models/autogenerated/Diagram'
import { ElementData } from '../../models/autogenerated/ElementData'
import { GraphvizOutput } from '../../models/graphviz/GraphvizOutput'
import { serializeToGraphvizDotCode } from './dot-serializer'
import { diagramContainsSubDiagrams } from '../../helper/diagram-helper'

export function generateAutoLayout(
  graphviz: Graphviz,
  diagram: Diagram,
): Record<string, ElementData> {
  const positions: Record<string, ElementData> = {}
  if (
    diagram.diagram_spec?.auto_layout_enabled &&
    diagram.diagram_spec.auto_layout_orientation &&
    diagram.diagram_plantuml?.elements
  ) {
    console.time('autoLayoutGeneration')
    const elements = diagram.diagram_plantuml.elements
    const diagramOrientation = diagram.diagram_spec.auto_layout_orientation
    const containsSubgraphs = diagramContainsSubDiagrams(elements)
    const pad = getPadInInch(containsSubgraphs)

    const graphvizDotCode = serializeToGraphvizDotCode(
      elements,
      diagramOrientation,
      pad,
    )
    // console.debug(graphvizDotCode)

    const output = JSON.parse(
      graphviz.dot(graphvizDotCode, 'json'),
    ) as GraphvizOutput
    const graphHeight = getGraphHeightInPtFromBB(output.bb)
    // console.debug(output)

    // Store the nodes positions
    output.objects?.forEach((object) => {
      if (
        !isSubgraphInvisibleNodeHack(object) &&
        !isSubgraphMarginHack(object)
      ) {
        if (object._draw_) {
          const objPositions = object._draw_.filter(
            (draw) => draw.op === 'p' || draw.op === 'P',
          )

          // I'll take the position at "0" index because _draw_ contains the draw data
          // of each periphery (inner boxes used as an hack to add a space between nodes). The first
          // draw data are the ones of the innermost box containing the diagram data, that is the
          // actual diagram box.
          // But it could be possible that the current object is a subgraph. In this case no peripheries
          // have been configured, so there will be just one position.
          const position = objPositions[0]

          const pxCoordsLT = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[0],
          )
          const pxCoordsLB = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[1],
          )
          const pxCoordsRB = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[2],
          )
          const pixelCoordinatesX = pxCoordsRB[0]
          const pixelCoordinatesY = pxCoordsLT[1]

          let size
          if (position.points.length === 4) {
            const width = pxCoordsRB[0] - pxCoordsLB[0]
            const height = pxCoordsLT[1] - pxCoordsLB[1]
            size = { x: width, y: height }
          }
          positions[object.name] = {
            position: { x: pixelCoordinatesX, y: pixelCoordinatesY },
            size,
          }
        }
      }
    })

    // Store the edges positions
    output.edges?.forEach((edge) => {
      const elementData: ElementData = {
        path: [],
      }

      // Edge points
      const edgePoints = edge._draw_.filter((draw) => draw.op === 'b')[0].points
      edgePoints.forEach((point, index) => {
        const pixelCoordinates = graphvizCoordinatesToPx(
          pad,
          graphHeight,
          point,
        )
        const x = pixelCoordinates[0]
        const y = pixelCoordinates[1]
        if (index === 0) elementData.start = { x, y }
        else
          elementData.path?.push({
            x,
            y,
          })
      })

      // Edge cap point
      const edgeCapPoints = edge._hdraw_.filter((draw) => draw.op === 'P')[0]
        .points
      const pixelCoordinates = graphvizCoordinatesToPx(
        pad,
        graphHeight,
        edgeCapPoints[1],
      )
      elementData.end = { x: pixelCoordinates[0], y: pixelCoordinates[1] }

      if (elementData.start && elementData.end)
        elementData.svg_path = svgPathFromGraphvizPos(
          edge.pos,
          elementData.start,
          elementData.end,
          pad,
          graphHeight,
        )

      // Edge label
      const labelPoint = edge._ldraw_?.filter((draw) => draw.op === 'T')[0].pt
      if (labelPoint) {
        const coords = graphvizCoordinatesToPx(pad, graphHeight, labelPoint)
        elementData.label_position = { x: coords[0], y: coords[1] }
      }

      positions[edge.name] = elementData
    })
  }

  // console.debug(positions)
  console.timeEnd('autoLayoutGeneration')
  return positions
}
