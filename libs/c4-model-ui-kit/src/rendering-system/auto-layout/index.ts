import { Graphviz } from '@hpcc-js/wasm-graphviz'
import {
  getGraphHeightInPtFromBB,
  getPadInInch,
  graphvizCoordinatesToPx,
  isSubgraphInvisibleNodeHack,
  isSubgraphMarginHack,
  svgPathFromGraphvizPos,
} from '../../helper/graphviz-helper'
import { Diagram } from '../../models/autogenerated/Diagram'
import { ElementData } from '../../models/autogenerated/ElementData'
import { GraphvizOutput } from '../../models/graphviz/GraphvizOutput'
import { PERIPHERY_SIZE, serializeToGraphvizDotCode } from './dot-serializer'
import { diagramContainsSubDiagrams } from '../../helper/diagram-helper'
import { ERROR_TRIANGULATION_FAILED } from '../../constants/errors'

export function generateAutoLayout(
  graphviz: Graphviz,
  diagram: Diagram,
): { positions: Record<string, ElementData>; errors: string[] } {
  const positions: Record<string, ElementData> = {}
  const errors: string[] = []
  if (
    diagram.diagram_spec?.auto_layout_enabled &&
    diagram.diagram_spec.auto_layout_orientation &&
    diagram.diagram_plantuml?.elements
  ) {
    console.time('autoLayoutGeneration')
    const elements = diagram.diagram_plantuml.elements
    const diagramOrientation = diagram.diagram_spec.auto_layout_orientation
    const ranksep = diagram.diagram_spec.auto_layout_ranksep
    const subgraphInnerMargin =
      diagram.diagram_spec.auto_layout_subgraph_inner_margin
    const subgraphOuterMargin =
      diagram.diagram_spec.auto_layout_subgraph_outer_margin
    const containsSubgraphs = diagramContainsSubDiagrams(elements)
    const pad = getPadInInch(containsSubgraphs)

    const graphvizDotCode = serializeToGraphvizDotCode(
      elements,
      diagramOrientation,
      ranksep,
      subgraphInnerMargin,
      subgraphOuterMargin,
      pad,
    )
    // console.debug(graphvizDotCode)

    const dotLayout = graphviz.dot(graphvizDotCode, 'json')
    const output = JSON.parse(dotLayout) as GraphvizOutput
    const graphHeight = getGraphHeightInPtFromBB(output.bb)

    // Store the nodes positions
    output.objects?.forEach((object) => {
      if (
        !isSubgraphInvisibleNodeHack(object) &&
        !isSubgraphMarginHack(object)
      ) {
        if (object._draw_) {
          const objPositions = object._draw_.filter(
            (draw) => draw.op === 'p' || draw.op === 'P',
          )

          // I'll take the position at "0" index because _draw_ contains the draw data
          // of each periphery (inner boxes used as an hack to add a space between nodes). The first
          // draw data are the ones of the innermost box containing the diagram data, that is the
          // actual diagram box.
          // But it could be possible that the current object is a subgraph. In this case no peripheries
          // have been configured, so there will be just one position.
          const position = objPositions[0]

          const pxCoordsLT = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[0],
          )
          const pxCoordsLB = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[1],
          )
          const pxCoordsRB = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            position.points[2],
          )
          const pixelCoordinatesX = pxCoordsLB[0]
          const pixelCoordinatesY = pxCoordsLB[1]

          let size
          if (position.points.length === 4) {
            const width = pxCoordsRB[0] - pxCoordsLB[0]
            const height = pxCoordsLT[1] - pxCoordsLB[1]
            size = { x: width, y: height }
          }
          positions[object.name] = {
            position: { x: pixelCoordinatesX, y: pixelCoordinatesY },
            size,
          }
        }
      }
    })

    // Store the edges positions
    output.edges?.forEach((edge) => {
      const elementData: ElementData = {
        path: [],
      }

      // Edge points
      if (edge._draw_) {
        const edgePoints = edge._draw_.filter((draw) => draw.op === 'b')[0]
          .points
        edgePoints.forEach((point, index) => {
          const pixelCoordinates = graphvizCoordinatesToPx(
            pad,
            graphHeight,
            point,
          )
          const x = pixelCoordinates[0]
          const y = pixelCoordinates[1]
          if (index === 0) elementData.start = { x, y }
          else
            elementData.path?.push({
              x,
              y,
            })
        })
      } else {
        // If the edge has no _draw_ data, it means that an error occurred on Graphviz side,
        // usually a triangulation error.
        errors.push(ERROR_TRIANGULATION_FAILED)
      }

      // Edge cap point
      if (edge._hdraw_) {
        const edgeCapPoints = edge._hdraw_.filter((draw) => draw.op === 'P')[0]
          .points
        const pixelCoordinates = graphvizCoordinatesToPx(
          pad,
          graphHeight,
          edgeCapPoints[1],
        )
        elementData.end = { x: pixelCoordinates[0], y: pixelCoordinates[1] }
      }

      // Edge label
      if (edge._ldraw_) {
        const labelPoint = edge._ldraw_?.filter((draw) => draw.op === 'T')[0].pt
        if (labelPoint) {
          const coords = graphvizCoordinatesToPx(pad, graphHeight, labelPoint)
          elementData.label_position = { x: coords[0], y: coords[1] }
        }
      }

      // Start and end positions adjustments + SVG path generation
      if (elementData.start && elementData.end) {
        // Adjust the start and end positions to connect the innermost boxes containing
        // the diagram data, and not the peripheries (excluding subgraphs since they
        // do not have peripheries).

        // ---- Start
        if (
          edge.keadex_fromissubgraph === 'false' &&
          elementData.path?.[0]?.x &&
          elementData.path?.[0]?.y
        ) {
          // x adjustment
          if (elementData.start.x < elementData.path[0].x) {
            elementData.start.x -= PERIPHERY_SIZE
          } else if (elementData.start.x > elementData.path[0].x) {
            elementData.start.x += PERIPHERY_SIZE
          }
          // y adjustment
          if (elementData.start.y < elementData.path[0].y) {
            elementData.start.y -= PERIPHERY_SIZE
          } else if (elementData.start.y > elementData.path[0].y) {
            elementData.start.y += PERIPHERY_SIZE
          }
        }

        // ---- End
        if (
          edge.keadex_toissubgraph === 'false' &&
          elementData.path?.[elementData.path?.length - 1]?.x &&
          elementData.path?.[elementData.path?.length - 1]?.y
        ) {
          // x adjustment
          if (
            elementData.end.x < elementData.path[elementData.path.length - 1].x
          ) {
            elementData.end.x -= PERIPHERY_SIZE
          } else if (
            elementData.end.x > elementData.path[elementData.path.length - 1].x
          ) {
            elementData.end.x += PERIPHERY_SIZE
          }
          // y adjustment
          if (
            elementData.end.y < elementData.path[elementData.path.length - 1].y
          ) {
            elementData.end.y -= PERIPHERY_SIZE
          } else if (
            elementData.end.y > elementData.path[elementData.path.length - 1].y
          ) {
            elementData.end.y += PERIPHERY_SIZE
          }
        }

        // Store the edge SVG path
        elementData.svg_path = svgPathFromGraphvizPos(
          edge.pos,
          elementData.start,
          elementData.end,
          pad,
          graphHeight,
        )
      }

      positions[edge.name] = elementData
    })
  }

  // console.debug(positions)
  console.timeEnd('autoLayoutGeneration')
  return {
    positions,
    errors,
  }
}
