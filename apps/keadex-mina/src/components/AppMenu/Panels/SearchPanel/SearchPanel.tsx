import {
  faAngleDown,
  faAngleRight,
  faSearch,
} from '@fortawesome/free-solid-svg-icons'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { c4ElementTypePathName } from '@keadex/c4-model-ui-kit'
import {
  Accordion,
  AccordionItem,
  Checkbox,
  IconButton,
  InputButton,
  faSearchAndReplace,
  useModal,
  useSafeExit,
} from '@keadex/keadex-ui-kit/cross'
import { sep } from '@tauri-apps/api/path'
import escape from 'escape-html'
import escapeStringRegexp from 'escape-string-regexp'
import React, { useContext, useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useLocation } from 'react-router-dom'
import AppEventContext from '../../../../context/AppEventContext'
import { openDiagram } from '../../../../core/router/router'
import ROUTES, {
  BASE_PATH_LIBRARY,
  EDIT_DIAGRAM,
} from '../../../../core/router/routes'
import { useAppSelector } from '../../../../core/store/hooks'
import {
  libraryElementTypeFromPath,
  search,
  searchAndReplace,
} from '../../../../core/tauri-rust-bridge'
import { FileSearchResult } from '../../../../models/autogenerated/FileSearchResult'
import { FileSearchResults } from '../../../../models/autogenerated/FileSearchResults'
import { toast } from 'react-toastify'

enum SearchAction {
  SearchOnly,
  SearchAndReplace,
}

type SearchFilter = {
  diagrams: boolean
  library: boolean
}

const DEFAULT_SEARCH_FILTERS: SearchFilter = {
  diagrams: true,
  library: true,
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface SearchPanelProps {}

export const SearchPanel = React.memo((props: SearchPanelProps) => {
  const location = useLocation()
  const { t } = useTranslation()
  const { modal: modalSafeExit, safeExit } = useSafeExit(ROUTES)
  const { modal, showModal, hideModal } = useModal()
  const project = useAppSelector((state) => state.project.value)
  const [isSearching, setIsSearching] = useState(false)
  const [searchValue, setSearchValue] = useState('')
  const [isReplacing, setIsReplacing] = useState(false)
  const [replaceValue, setReplaceValue] = useState('')
  const [searchFilters, setSearchFilters] = useState<SearchFilter>(
    DEFAULT_SEARCH_FILTERS,
  )
  const [isReplaceActive, setIsReplaceActive] = useState(false)

  const [renderedSearchResults, setRenderedSearchResults] =
    useState<JSX.Element>(<></>)
  const context = useContext(AppEventContext)

  function highlightResult(results: string, searchedValue: string): string {
    const regex = new RegExp(escapeStringRegexp(searchedValue), 'gi')
    return escape(results).replace(regex, (match) => {
      return `<span class='search-highlighted'>${escape(match)}</span>`
    })
  }

  async function openLibrary(path: string) {
    const c4ElementType = await libraryElementTypeFromPath(path)
    safeExit(`${BASE_PATH_LIBRARY}${c4ElementTypePathName(c4ElementType)}`)
  }

  async function handleSearchResultItemClick(item?: FileSearchResult[]) {
    if (item && item.length > 0) {
      const category = item[0].category
      const path = item[0].path
      if (category === 'Diagram') {
        await openDiagram(path, 'fs_path', location.pathname, context, safeExit)
      } else if (category === 'Library') {
        await openLibrary(path)
      }
    }
  }

  function renderResults(
    searchedValue: string,
    searchResults?: FileSearchResults,
  ): JSX.Element {
    if (searchedValue.replace(/ /g, '').length > 0) {
      if (searchResults && Object.keys(searchResults.results).length > 0) {
        const result =
          searchResults.count === 1
            ? t('common.result').toLowerCase()
            : t('common.results').toLowerCase()
        let count = `${searchResults.count} ${result}`
        if (searchResults.reached_limit) {
          count = t('common.info.limit_results', { count: searchResults.count })
        }

        const accordionItems: AccordionItem<FileSearchResult[]>[] = []
        Object.keys(searchResults.results).forEach((filePath) => {
          accordionItems.push({
            header: project?.project_settings.root
              ? filePath.replace(
                  new RegExp(
                    escapeStringRegexp(
                      `${project.project_settings.root}${sep()}`,
                    ),
                    'gi',
                  ),
                  '',
                )
              : filePath,
            body: highlightResult(
              searchResults.results[filePath]
                .map((result) => result.line_content)
                .join('\n'),
              searchedValue,
            ),
            parseHtmlBody: true,
            data: searchResults.results[filePath],
          })
        })
        return (
          <div className="contents h-full">
            <div className="mb-2 w-full px-4 text-left text-sm">{count}</div>
            <Accordion<FileSearchResult[]>
              id="search-results"
              className="h-full overflow-auto"
              items={accordionItems}
              showButtonTooltip
              buttonIconPosition="left"
              onBodyClick={(item) => handleSearchResultItemClick(item)}
            />
          </div>
        )
      } else {
        return <span className="mt-4">{t('common.info.no_results')}</span>
      }
    }
    return <></>
  }

  function canReplace() {
    const allowedReplaceDiagrams =
      !searchFilters.diagrams ||
      (searchFilters.diagrams &&
        location.pathname !== ROUTES[EDIT_DIAGRAM].path)
    const allowedReplaceLibrary =
      !searchFilters.library ||
      (searchFilters.library &&
        !location.pathname.startsWith(BASE_PATH_LIBRARY))

    if (!allowedReplaceDiagrams) {
      toast.error(t('common.error.cannot_change_diagrams'))
    } else if (!allowedReplaceLibrary) {
      toast.error(t('common.error.cannot_change_library'))
    }
    return (
      searchValue.replace(/ /g, '').length > 0 &&
      allowedReplaceDiagrams &&
      allowedReplaceLibrary
    )
  }

  async function handleSearch() {
    if (searchValue.replace(/ /g, '').length > 0) {
      setIsSearching(true)
      let results = await search(
        searchValue,
        searchFilters.diagrams,
        searchFilters.library,
        1000,
      )
      setIsSearching(false)
      setRenderedSearchResults(renderResults(searchValue, results))
      return results
    }
  }

  async function handleReplace() {
    if (canReplace()) {
      const results = await handleSearch()
      if (results && results.count > 0) {
        const numOccurrences = Object.keys(results.results).reduce(
          (acc, key) => acc + (results.results[key]?.length ?? 0),
          0,
        )
        const numFiles = results.count
        if (results) {
          showModal({
            id: 'confirmReplaceAllModal',
            title: t('common.confirmation').toString(),
            body: t('common.question.confirm_replace_all', {
              numOccurrences,
              numFiles,
            }).toString(),
            buttons: [
              {
                key: 'button-cancel',
                children: <span>{t('common.cancel')}</span>,
                'data-te-modal-dismiss': true,
              },
              {
                key: 'button-confirm',
                children: <span>{t('common.replace')}</span>,
                className: 'button--safe',
                onClick: () => {
                  setIsReplacing(true)
                  searchAndReplace(
                    searchValue,
                    replaceValue,
                    searchFilters.diagrams,
                    searchFilters.library,
                  ).then(() => {
                    setIsReplacing(false)
                    hideModal()
                    handleSearch()
                  })
                },
              },
            ],
          })
        }
      }
    }
  }

  async function handleKeyDown(
    e: React.KeyboardEvent<HTMLInputElement>,
    action: SearchAction,
  ) {
    if (e.key === 'Enter') {
      switch (action) {
        case SearchAction.SearchOnly:
          handleSearch()
          break
        case SearchAction.SearchAndReplace:
          handleReplace()
          break
      }
    }
  }

  useEffect(() => {
    // Commenting the following condition will cause the search panel
    // to be reset everytime the project changes (not only when it will be closed).
    // For example, when the user creates a new element in the library,
    // the project is re-saved and changes.
    // As a consequence the search panel will be reset.
    // For now, this behaviour is acceptable.
    // if (project === undefined) {
    setSearchValue('')
    setReplaceValue('')
    setRenderedSearchResults(<></>)
    setSearchFilters(DEFAULT_SEARCH_FILTERS)
    // }
  }, [project])

  return (
    <div id="search-panel" className="flex h-full flex-col text-center">
      {modalSafeExit}
      {modal}

      <div className="p-4 pb-0">
        {/* ----- Header ----- */}
        <div className="text-brand1 mt-4 text-4xl">
          <FontAwesomeIcon icon={faSearch} />
        </div>
        <div className="text-accent-primary mt-2 text-lg font-bold pointer-events-none">
          {t('common.search')}
        </div>

        {/* ----- Form ----- */}
        <div className="mt-5">
          <div className="flex">
            <IconButton
              icon={isReplaceActive ? faAngleDown : faAngleRight}
              className="icon w-5 text-left text-[0.9rem] self-start mt-[0.85rem]"
              onClick={() => setIsReplaceActive(!isReplaceActive)}
            />
            <div className="w-full mr-4 ml-[0.1rem]">
              <InputButton
                autoComplete="off"
                value={searchValue}
                onKeyDown={(e) => handleKeyDown(e, SearchAction.SearchOnly)}
                fixedWidth
                loading={isSearching}
                onChange={(e) => {
                  setSearchValue(e.target.value)
                }}
                onIconClick={() => handleSearch()}
              />
              {isReplaceActive && (
                <InputButton
                  autoComplete="off"
                  value={replaceValue}
                  onKeyDown={(e) =>
                    handleKeyDown(e, SearchAction.SearchAndReplace)
                  }
                  icon={faSearchAndReplace}
                  fixedWidth
                  loading={isReplacing}
                  onChange={(e) => {
                    setReplaceValue(e.target.value)
                  }}
                  onIconClick={() => handleReplace()}
                />
              )}
            </div>
          </div>
          <Checkbox
            id="search-filters"
            className="mt-3 mb-5 ml-5 !justify-start text-sm leading-[1.7]"
            options={[
              {
                id: 'diagrams',
                label: t('common.diagrams'),
                value: true,
              },
              {
                id: 'library',
                label: t('common.library'),
                value: true,
              },
            ]}
            onChange={(id: string, value: boolean) => {
              let newFilters = { ...searchFilters }
              newFilters[id as keyof SearchFilter] = value
              setSearchFilters(newFilters)
            }}
            values={searchFilters}
          />
        </div>
      </div>

      {/* ----- Results ----- */}
      {renderedSearchResults}
    </div>
  )
})

export default SearchPanel
