import {
  C4ElementType,
  C4ElementTypeExtended,
  Component,
  Container,
  DIAGRAM_ELEMENTS_TYPES,
  Diagram,
  DiagramElementType,
  DiagramPlantUML,
  SoftwareSystem,
  componentDiagramElement,
  containerDiagramElement,
  softwareSystemDiagramElement,
} from '@keadex/c4-model-ui-kit'
import { useModal } from '@keadex/keadex-ui-kit/cross'
import Editor, { loader } from '@monaco-editor/react'
import * as monaco from 'monaco-editor'
import {
  Ref,
  forwardRef,
  useEffect,
  useImperativeHandle,
  useRef,
  useState,
} from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'react-toastify'
import AISpeechBubble from '../../../components/AISpeechBubble/AISpeechBubble'
import { DiagramEditorToolbarCommands } from '../../../components/DiagramEditorToolbar/DiagramEditorToolbar'
import DiagramPicker from '../../../components/DiagramPicker/DiagramPicker'
import ModalImportLibraryElement from '../../../components/ModalImportLibraryElement/ModalImportLibraryElement'
import {
  deserializePlantUMLByString,
  parsedElementToPlantUML,
} from '../../../core/tauri-rust-bridge'
import { MinaError } from '../../../models/autogenerated/MinaError'
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput'
import { useForceUpdate } from '@keadex/keadex-ui-kit/cross'
import { snakeCase } from 'change-case'
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { QuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/browser/quickInputService'
import ModalCRUComponent from '../../../components/ModalCRULibraryElement/ModalCRUComponent/ModalCRUComponent'
import ModalCRUContainer from '../../../components/ModalCRULibraryElement/ModalCRUContainer/ModalCRUContainer'
import ModalCRUPerson from '../../../components/ModalCRULibraryElement/ModalCRUPerson/ModalCRUPerson'
import ModalCRUSoftwareSystem from '../../../components/ModalCRULibraryElement/ModalCRUSoftwareSystem/ModalCRUSoftwareSystem'
import ModalCRUBoundary from '../../../components/ModalCRULibraryElement/ModalCRUBoundary/ModalCRUBoundary'
import ModalCRUDeploymentNode from '../../../components/ModalCRULibraryElement/ModalCRUDeploymentNode/ModalCRUDeploymentNode'
import ModalCRURelationship from '../../../components/ModalCRULibraryElement/ModalCRURelationship/ModalCRURelationship'

loader.config({ monaco })

// https://github.com/opensumi/monaco-editor-core/blob/main/src/vs/platform/quickinput/common/quickInput.ts
// For some reasons monaco does not export this type...
export interface IQuickPickItem {
  type?: 'item'
  id?: string
  label: string
}

export interface DiagramCodeViewProps {
  diagram?: Diagram
  error?: MinaError
  diagramEditorToolbarCommands: DiagramEditorToolbarCommands | null
  saveDiagram: () => void
  isSaving: boolean
}

export interface DiagramCodeViewCommands {
  resetCode: () => void
  getUpdatedRawPlantUML: () => string | undefined
  undo: () => void
  redo: () => void
  canUndo: () => boolean
  canRedo: () => boolean
  copy: () => void
  cut: () => void
  paste: () => void
  find: () => void
  commands: () => void
  openAI: () => void
  addCodeAtCursorPosition: (code: string, cursorPosition?: number) => void
  importFromLibrary: () => void
  addDiagramElement: (
    c4ElementType: C4ElementType | C4ElementTypeExtended,
  ) => void
  addDiagramLink: () => void
  replaceLineContent: (lineNumber: number, newContent: string) => void
}

export const DiagramCodeView = forwardRef(
  (props: DiagramCodeViewProps, ref: Ref<DiagramCodeViewCommands>) => {
    const { diagram, saveDiagram, isSaving } = props

    const { t } = useTranslation()
    const { modal, showModal, hideModal } = useModal()
    const { forceUpdate } = useForceUpdate()

    const editorRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null)
    const [rawPlantuml, setRawPlantuml] = useState('')
    const [editorPosition, setEditorPosition] =
      useState<monaco.Position | null>(null)
    const [currentVersionID, setCurrentVersionID] = useState(-1)
    const [initialVersionID, setInitialVersionID] = useState(-1)
    const [lastVersionID, setLastVersionID] = useState(-1)
    const [aiHidden, setAiHidden] = useState(true)
    const canEditorUndo = useRef(false)
    const canEditorRedo = useRef(false)

    useEffect(() => {
      function handle(e: KeyboardEvent) {
        if (e.key.toUpperCase() === 'S' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault()
          saveDiagram()
        }
      }
      document.addEventListener('keydown', handle)
      return () => document.removeEventListener('keydown', handle)
    }, [diagram, editorPosition, saveDiagram])

    useEffect(() => {
      editorRef?.current?.setPosition({ lineNumber: 0, column: 0 })
      if (editorRef.current && editorPosition) {
        editorRef.current.focus()
        editorRef.current.setPosition(editorPosition)
        editorRef.current.updateOptions({ readOnly: isSaving })
      }
    })

    useEffect(() => {
      if (diagram) {
        const { raw_plantuml } = diagram
        setRawPlantuml(raw_plantuml ?? '')
      }
    }, [diagram])

    useImperativeHandle(ref, () => ({
      resetCode: () => {
        setRawPlantuml('')
      },
      getUpdatedRawPlantUML: (): string | undefined => {
        if (
          diagram &&
          diagram.diagram_name &&
          diagram.diagram_type &&
          editorRef.current
        ) {
          return editorRef.current.getValue()
        }
      },
      canUndo: (): boolean => {
        return canEditorUndo.current
      },
      canRedo: (): boolean => {
        return canEditorRedo.current
      },
      undo: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'undo', {})
      },
      redo: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'redo', {})
      },
      copy: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'editor.action.clipboardCopyAction', {})
      },
      cut: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'editor.action.clipboardCutAction', {})
      },
      paste: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'editor.action.clipboardPasteAction', {})
      },
      find: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'actions.find', {})
      },
      commands: () => {
        editorRef.current?.focus()
        editorRef.current?.trigger('', 'editor.action.quickCommand', {})
      },
      openAI: () => {
        setAiHidden(false)
      },
      addCodeAtCursorPosition: addCodeAtCursorPosition,
      importFromLibrary: importFromLibrary,
      addDiagramElement: addDiagramElement,
      addDiagramLink: addDiagramLink,
      replaceLineContent: replaceLineContent,
    }))

    function handleEditorDidMount(editor: monaco.editor.IStandaloneCodeEditor) {
      editor.getModel()?.setEOL(monaco.editor.EndOfLineSequence.LF)
      editorRef.current = editor
      const versionID =
        editorRef.current.getModel()?.getAlternativeVersionId() ?? -1
      setCurrentVersionID(versionID)
      setInitialVersionID(versionID)
      setLastVersionID(versionID)
      setContextMenu(editorRef.current)
    }

    function setContextMenu(editor: monaco.editor.IStandaloneCodeEditor) {
      editor.addAction({
        id: 'import-from-library',
        label: t('diagram_editor.import_from_library'),
        contextMenuGroupId: '1_modification',
        contextMenuOrder: 1,
        run: function (ed) {
          importFromLibrary()
        },
      })
      editor.addAction({
        id: 'add-diagram-link',
        label: t('diagram_editor.add_diagram_link'),
        contextMenuGroupId: '1_modification',
        contextMenuOrder: 1,
        run: function (ed) {
          addDiagramLink()
        },
      })

      const quickInputCommand = editor.addCommand(
        0,
        (accessor, func, a, b, c) => {
          // a hacker way to get the input service
          func(accessor.get(IQuickInputService))
        },
      )

      if (quickInputCommand) {
        editor.addAction({
          id: 'add-diagram-element',
          label: t('diagram_editor.add_diagram_element'),
          contextMenuGroupId: '1_modification',
          contextMenuOrder: 1,

          run: function () {
            editor.trigger(
              '',
              quickInputCommand,
              (quickInput: QuickInputService) => {
                quickInput
                  .pick(
                    DIAGRAM_ELEMENTS_TYPES.map((diagramElementType) => {
                      return {
                        type: 'item',
                        id: diagramElementType,
                        label: t(`common.${snakeCase(diagramElementType)}`),
                      }
                    }),
                  )
                  .then((selected?: IQuickPickItem) => {
                    if (selected?.id)
                      addDiagramElement(
                        selected.id as C4ElementType | C4ElementTypeExtended,
                      )
                  })
              },
            )
          },
        })
      }
    }

    function handleEditorChange(
      value: string | undefined,
      ev: monaco.editor.IModelContentChangedEvent,
    ) {
      if (editorRef.current?.getModel())
        setRawPlantuml(editorRef.current?.getModel()!.getValue())

      setEditorPosition(editorRef.current?.getPosition() ?? null)

      const versionId =
        editorRef.current?.getModel()?.getAlternativeVersionId() ?? -1
      // undoing
      if (versionId < currentVersionID) {
        canEditorRedo.current = true
        // no more undo possible
        if (versionId === initialVersionID) {
          canEditorUndo.current = false
        }
      } else {
        // redoing
        if (versionId <= lastVersionID) {
          // redoing the last change
          if (versionId === lastVersionID) {
            canEditorRedo.current = false
          }
        } else {
          // adding new change, disable redo when adding new changes
          canEditorRedo.current = false
          if (currentVersionID > lastVersionID) {
            setLastVersionID(currentVersionID)
          }
        }
        canEditorUndo.current = true
      }
      setCurrentVersionID(versionId)

      props.diagramEditorToolbarCommands?.forceUpdate()
    }

    function addCodeAtCursorPosition(code: string, cursorPosition?: number) {
      editorRef.current?.focus()
      editorRef.current?.trigger('keyboard', 'type', { text: code })
    }

    function replaceLineContent(lineNumber: number, newContent: string) {
      const editor = editorRef.current
      const model = editor?.getModel()

      if (editor && model) {
        // Get the current selection of the editor
        const currentSelection = editor.getSelection()

        // Get the current content of the editor
        const currentContent = editor.getValue()

        // Split the content into lines
        const lines = currentContent?.split('\n')

        if (lines) {
          // Replace the content of the specified line number
          if (lineNumber >= 1 && lineNumber <= lines.length) {
            lines[lineNumber - 1] = newContent
          }

          // Join the modified lines back into a single string
          const updatedLines = lines.join('\n')

          // Set the new content for the editor
          const editOperation = {
            range: model.getFullModelRange(),
            text: updatedLines,
            forceMoveMarkers: false,
          }
          editor.executeEdits(
            'replaceLineContent',
            [editOperation],
            currentSelection !== null ? [currentSelection] : [],
          )
          editor.pushUndoStop()
        }
      }
    }

    function importFromLibrary() {
      setEditorPosition(editorRef.current?.getPosition() ?? null)
      showModal({
        id: 'importLibraryElementModal',
        title: t('diagram_editor.import_from_library').toString(),
        body: (
          <ModalImportLibraryElement
            onLibraryElementSelected={(libraryElement: DiagramElementType) => {
              parsedElementToPlantUML(libraryElement)
                .then((plantUML) => {
                  addCodeAtCursorPosition(plantUML)
                  toast.success(t('diagram_editor.element_imported'))
                })
                .catch((error: MinaError) => {
                  toast.error(
                    t('common.error.internal', {
                      errorMessage: error.msg ?? error,
                    }),
                  )
                })
            }}
            hideModal={hideModal}
          />
        ),
        buttons: false,
        size: 'full',
      })
    }

    async function addDiagramElement(
      c4ElementType: C4ElementType | C4ElementTypeExtended,
    ) {
      setEditorPosition(editorRef.current?.getPosition() ?? null)
      let Modal = ModalCRUPerson
      switch (c4ElementType) {
        case 'Person':
          Modal = ModalCRUPerson
          break
        case 'Container':
          Modal = ModalCRUContainer
          break
        case 'Component':
          Modal = ModalCRUComponent
          break
        case 'SoftwareSystem':
          Modal = ModalCRUSoftwareSystem
          break
        case 'Boundary':
          Modal = ModalCRUBoundary
          break
        case 'DeploymentNode':
          Modal = ModalCRUDeploymentNode
          break
        case 'Relationship':
          Modal = ModalCRURelationship
          break
      }
      const onElementCreated = (element: DiagramElementType) => {
        parsedElementToPlantUML(element)
          .then((plantUML) => {
            // Remove the closing bracket since the Monaco editor automatically adds it
            if ('Boundary' in element || 'DeploymentNode' in element) {
              plantUML = plantUML.replace('}', '')
            }
            addCodeAtCursorPosition(plantUML)
          })
          .catch((error: MinaError) => {
            toast.error(
              t('common.error.internal', {
                errorMessage: error.msg ?? error,
              }),
            )
          })
      }

      showModal({
        id: `${c4ElementType.toLowerCase()}Modal`,
        title: `${t('common.new')} ${t(`common.${snakeCase(c4ElementType)}`)}`,
        body: (
          <Modal
            mode="serializer"
            enableEdit={true}
            hideModal={hideModal}
            forceUpdate={forceUpdate}
            onElementCreated={onElementCreated}
          />
        ),
        buttons: false,
      })
    }

    async function addDiagramLink() {
      const cursorPosition = editorRef.current?.getPosition()
      setEditorPosition(cursorPosition ?? null)
      const selection = editorRef.current?.getSelection()
      if (selection && cursorPosition) {
        if (
          selection.startLineNumber === selection.endLineNumber &&
          selection.startLineNumber === cursorPosition.lineNumber
        ) {
          const selectedPlantUMLLine = editorRef.current
            ?.getModel()
            ?.getLineContent(cursorPosition.lineNumber)
          if (selectedPlantUMLLine) {
            let result: DiagramPlantUML | undefined
            try {
              result = await deserializePlantUMLByString(
                `@startuml\n${selectedPlantUMLLine}\n@enduml`,
              )
            } catch (e) {
              result = undefined
            }
            const elementToLink =
              result !== undefined &&
              result.elements !== undefined &&
              result.elements.length === 1 &&
              (softwareSystemDiagramElement(result.elements[0]) ||
                containerDiagramElement(result.elements[0]) ||
                componentDiagramElement(result.elements[0]))

            if (
              elementToLink !== undefined &&
              typeof elementToLink !== 'boolean'
            ) {
              const typedElementToLink = elementToLink as
                | SoftwareSystem
                | Container
                | Component
              showModal({
                id: 'linkDiagramModal',
                title: t('common.action.link_to_diagram', {
                  alias: typedElementToLink.base_data.alias,
                }).toString(),
                body: (
                  <DiagramPicker
                    className="!mb-0 !mt-0 p-6"
                    value={typedElementToLink.base_data.link}
                    onDiagramSelected={async (diagram) => {
                      typedElementToLink.base_data.link = diagram
                      let updatedPlantUML = selectedPlantUMLLine
                      if (softwareSystemDiagramElement(result!.elements[0])) {
                        updatedPlantUML = await parsedElementToPlantUML({
                          SoftwareSystem: typedElementToLink,
                        })
                      } else if (containerDiagramElement(result!.elements[0])) {
                        updatedPlantUML = await parsedElementToPlantUML({
                          Container: typedElementToLink,
                        })
                      } else if (componentDiagramElement(result!.elements[0])) {
                        updatedPlantUML = await parsedElementToPlantUML({
                          Component: typedElementToLink,
                        })
                      }
                      replaceLineContent(
                        cursorPosition.lineNumber,
                        updatedPlantUML.replaceAll('\n', ''),
                      )
                      hideModal()
                    }}
                  />
                ),
                buttons: false,
                size: 'md',
              })
              return
            }
          }
        }
      }
      toast.error(t('common.error.cannot_add_diagram_link'))
    }

    return (
      <div className="relative h-full w-full">
        {modal}
        <Editor
          className={`h-full ${!diagram ? 'hidden' : ''}`}
          language="plantuml"
          value={rawPlantuml}
          theme="vs-dark"
          onMount={handleEditorDidMount}
          onChange={handleEditorChange}
          options={{ wordWrap: 'on', tabSize: 2 }}
        />
        <div
          className={`${
            isSaving ? 'opacity-90' : 'opacity-0'
          } bg-dark-brand1 z-[6] absolute bottom-5 left-1/2 -translate-x-1/2 text-center transition duration-200 ease-in-out px-10 py-1 rounded pointer-events-none`}
        >
          {t('common.saving')}...
        </div>
        <AISpeechBubble
          aiHidden={aiHidden}
          addCodeAtCursorPosition={addCodeAtCursorPosition}
          diagram={diagram}
          closeAI={() => setAiHidden(true)}
        />
      </div>
    )
  },
)

export default DiagramCodeView
