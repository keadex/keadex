import {
  Diagram,
  DiagramListener,
  DiagramSpec,
  getBoundingBox,
  getCanvasPan,
  renderDiagram,
  updateDiagramElementsSpecsFromCanvas,
} from '@keadex/c4-model-ui-kit'
import { KeadexCanvas } from '@keadex/keadex-ui-kit/cross'
import { fabric } from 'fabric'
import {
  Ref,
  forwardRef,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useRef,
} from 'react'
import { useTranslation } from 'react-i18next'
import { useResizeDetector } from 'react-resize-detector'
import { toast } from 'react-toastify'
import DiagramDesignViewToolbar from '../../../components/DiagramDesignViewToolbar/DiagramDesignViewToolbar'
import { exportDiagramToFile } from '../../../core/tauri-rust-bridge'
import { MinaError } from '../../../models/autogenerated/MinaError'
import { objectsAreEqual } from '@keadex/keadex-utils'

const MARGIN_EXPORTED_DIAGRAM = 50

export interface KeadexCanvasState {
  zoom: number
  pan: { panX: number; panY: number }
}

export interface DiagramDesignViewProps {
  diagramListener: DiagramListener
  diagram?: Diagram
  error?: MinaError
}

export interface DiagramDesignViewCommands {
  resetCanvas: (canvasState?: KeadexCanvasState) => void
  getUpdatedDiagramSpec: () => DiagramSpec | undefined
  getCanvasState: () => KeadexCanvasState
  exportDiagram: () => void
  isDiagramChanged: () => boolean
}

export const DiagramDesignView = forwardRef(
  (props: DiagramDesignViewProps, ref: Ref<DiagramDesignViewCommands>) => {
    const { diagram, diagramListener } = props

    const { t } = useTranslation()
    const canvas = useRef<KeadexCanvas>()
    const canvasEl = useRef<HTMLCanvasElement>(null)
    const parentDivEl = useRef<HTMLDivElement>(null)
    const { ref: rootDiv } = useResizeDetector()
    const currentRenderedDiagram = useRef<Diagram | null>()
    const isDiagramChanged = useRef<boolean>(false)

    if (!objectsAreEqual(currentRenderedDiagram.current, diagram)) {
      currentRenderedDiagram.current = diagram
    }

    function canvasModifiedCallback() {
      isDiagramChanged.current = true
    }

    function createCanvas(canvasState?: KeadexCanvasState) {
      const options: fabric.ICanvasOptions = {
        fireRightClick: true,
        fireMiddleClick: true,
        stopContextMenu: true,
        backgroundColor: 'white',
      }
      const localCanvas = new KeadexCanvas(canvasEl.current, options)

      localCanvas.on('object:added', canvasModifiedCallback)
      localCanvas.on('object:removed', canvasModifiedCallback)
      localCanvas.on('object:modified', canvasModifiedCallback)

      isDiagramChanged.current = false

      // Reset the state of the canvas (if any)
      if (canvasState) {
        localCanvas.setZoom(canvasState.zoom)
        localCanvas.relativePan(
          new fabric.Point(canvasState.pan.panX, canvasState.pan.panY)
        )
      }

      canvas.current = localCanvas
    }

    function destroyCanvas() {
      if (canvas.current) {
        canvas.current.dispose()
        canvas.current = undefined
      }
    }

    async function exportDiagram() {
      if (diagram?.diagram_name && diagram.diagram_type && canvas.current) {
        const format = 'png' //TODO
        console.debug(`Exporting to ${format}`)

        // Temporary reset the viewport transform in order to ignore zoom and pan
        // in the exported diagram.
        const originalTransform = canvas.current.viewportTransform
        canvas.current.viewportTransform = fabric.iMatrix.slice(0)

        // Calculate the bounding box of all the objects of the canvas in order to
        // export also the objects "outside" the canvas and not visible in the viewport
        let { width, height, left, top } = getBoundingBox(
          canvas.current.getObjects()
        )
        if (width && height && left && top) {
          width += MARGIN_EXPORTED_DIAGRAM
          height += MARGIN_EXPORTED_DIAGRAM
          left -= MARGIN_EXPORTED_DIAGRAM / 2
          top -= MARGIN_EXPORTED_DIAGRAM / 2
        }

        await exportDiagramToFile(
          diagram.diagram_name,
          diagram.diagram_type,
          canvas.current.toDataURL({
            format,
            enableRetinaScaling: true,
            width,
            height,
            left,
            top,
          }),
          format
        )
          .then((pathExportedDiagram) =>
            toast.success(
              t('common.info.diagram_exported', { pathExportedDiagram })
            )
          )
          .catch((error: MinaError) => toast.success(error.msg))

        // Restore the original viewport transform (with zoom and pan)
        canvas.current.viewportTransform = originalTransform
      }
    }

    useImperativeHandle(ref, () => ({
      exportDiagram,
      resetCanvas: (canvasState?: KeadexCanvasState) => {
        destroyCanvas()
        createCanvas(canvasState)
      },

      getUpdatedDiagramSpec: (): DiagramSpec | undefined => {
        if (
          diagram &&
          diagram.diagram_plantuml &&
          diagram.diagram_spec &&
          diagram.diagram_name &&
          diagram.diagram_type
        ) {
          const updatedSpecs = updateDiagramElementsSpecsFromCanvas(
            canvas.current
          )
          return { ...diagram.diagram_spec, elements_specs: updatedSpecs }
        }
      },

      getCanvasState: (): KeadexCanvasState => {
        return {
          zoom: canvas.current?.getZoom() ?? 1,
          pan: getCanvasPan(canvas.current),
        }
      },

      isDiagramChanged: (): boolean => {
        return isDiagramChanged.current
      },
    }))

    useLayoutEffect(() => {
      console.debug('Diagram Design View changed layout')
      if (
        canvasEl.current &&
        parentDivEl.current?.clientWidth &&
        parentDivEl.current?.clientHeight
      ) {
        console.debug('Canvas resize')
        // Following is needed because if you calculate the new height without hiding
        // the inner canvas, it will have the full height of the div, which is not correct.
        // The real height takes also into account other divs before the canvas one.
        if (canvasEl.current.parentElement)
          canvasEl.current.parentElement.style.display = 'none'
        canvas.current?.setWidth(
          parentDivEl.current?.getBoundingClientRect().width
        )
        canvas.current?.setHeight(
          parentDivEl.current?.getBoundingClientRect().height
        )
        if (canvasEl.current.parentElement)
          canvasEl.current.parentElement.style.display = 'flex'
        canvas.current?.renderAll()
      }
    })

    useEffect(() => {
      if (canvasEl.current && !canvas.current) {
        createCanvas()
      }
      return () => {
        destroyCanvas()
      }
    }, [])

    useEffect(() => {
      if (canvas.current && currentRenderedDiagram.current) {
        renderDiagram(
          canvas.current,
          diagramListener,
          currentRenderedDiagram.current
        )
        isDiagramChanged.current = false
      }
    }, [currentRenderedDiagram.current])

    return (
      <div className="relative h-full w-full border" ref={rootDiv}>
        <DiagramDesignViewToolbar canvas={canvas.current} />
        <div className="h-full w-full flex-row flex-wrap" ref={parentDivEl}>
          <canvas ref={canvasEl} />
        </div>
      </div>
    )
  }
)

export default DiagramDesignView
