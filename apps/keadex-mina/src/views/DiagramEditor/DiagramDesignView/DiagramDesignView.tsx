import {
  CANVAS_EVENTS,
  Diagram,
  DiagramElementSpec,
  DiagramListener,
  DiagramOrientation,
  DiagramSpec,
  DiagramsThemeSettings,
  ELEMENT,
  getBoundingBox,
  getCanvasPan,
  invalidateCanvasCache,
  DiagramRenderer,
  updateDiagramElementsSpecsFromCanvas,
  DEFAULT_SUBGRAPH_INNER_MARGIN,
  DEFAULT_SUBGRAPH_OUTER_MARGIN,
} from '@keadex/c4-model-ui-kit'
import {
  KeadexCanvas,
  KeadexCanvasOptions,
  useModal,
} from '@keadex/keadex-ui-kit/cross'
import { objectsAreEqual } from '@keadex/keadex-utils'
import { fabric } from 'fabric'
import {
  Ref,
  forwardRef,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useRef,
  useState,
  RefObject,
} from 'react'
import { useTranslation } from 'react-i18next'
import { useResizeDetector } from 'react-resize-detector'
import { toast } from 'react-toastify'
import DiagramDesignViewFloatMenu from '../../../components/DiagramDesignViewFloatMenu/DiagramDesignViewFloatMenu'
import { exportDiagramToFile } from '../../../core/tauri-rust-bridge'
import { MinaError } from '../../../models/autogenerated/MinaError'
import FontFaceObserver from 'fontfaceobserver'
import { DiagramDesignViewToolbarCommands } from '../../../components/DiagramDesignViewToolbar/DiagramDesignViewToolbar'
import ModalAutoLayout from '../../../components/ModalAutoLayout/ModalAutoLayout'
import DiagramInfoPanel from '../../../components/DiagramInfoPanel/DiagramInfoPanel'
import ModalDiagramDesignViewSettings from '../../../components/ModalDiagramDesignViewSettings/ModalDiagramDesignViewSettings'
import { useHotkeys } from 'react-hotkeys-hook'
import { Key } from 'ts-key-enum'

const MARGIN_EXPORTED_DIAGRAM = 50

export interface KeadexCanvasState {
  zoom: number
  pan: { panX: number; panY: number }
}

export interface DiagramDesignViewProps {
  diagramDesignViewToolbarCommands?: RefObject<DiagramDesignViewToolbarCommands>
  diagramListener: DiagramListener
  diagramsThemeSettings?: DiagramsThemeSettings
  diagram?: Diagram
  error?: MinaError
  saveDiagram?: () => void
  readOnly?: boolean
  target: 'web' | 'desktop'
}

export type DiagramDesignViewSettings = {
  gridEnabled?: boolean
}

export interface DiagramDesignViewCommands {
  resetCanvas: (canvasState?: KeadexCanvasState) => void
  getUpdatedDiagramSpec: () => DiagramSpec | undefined
  getCanvasState: () => KeadexCanvasState
  exportDiagram: () => void
  isDiagramChanged: () => boolean
  undo: () => void
  redo: () => void
  canUndo: () => boolean
  canRedo: () => boolean
  isAutoLayoutEnabled(): boolean
  autoLayoutOrientation(): DiagramOrientation
  isGenerateOnlyStraightArrowsEnabled(): boolean
  ranksep(): number
  subgraphInnerMargin(): number
  subgraphOuterMargin(): number
  updateAutoLayoutOptions(
    enabled: boolean,
    orientation: DiagramOrientation,
    generateOnlyStraightArrows: boolean,
    ranksep: number,
    subgraphInnerMargin: number,
    subgraphOuterMargin: number,
  ): void
  updateDiagramDesignViewSettings: (
    settings?: DiagramDesignViewSettings,
  ) => void
  diagramDesignViewSettings: () => DiagramDesignViewSettings | undefined
}

export const DiagramDesignView = forwardRef(
  (props: DiagramDesignViewProps, ref: Ref<DiagramDesignViewCommands>) => {
    const {
      readOnly,
      diagram,
      diagramListener,
      diagramDesignViewToolbarCommands,
      saveDiagram,
      diagramsThemeSettings,
    } = props

    const { t } = useTranslation()
    const canvas = useRef<KeadexCanvas>()
    const canvasEl = useRef<HTMLCanvasElement>(null)
    const parentDivEl = useRef<HTMLDivElement>(null)
    const { ref: rootDiv } = useResizeDetector()
    const currentRenderedDiagram = useRef<Diagram | null>()
    const isDiagramChanged = useRef<boolean>(false)
    const mouseOnCanvas = useRef<boolean>(false)

    const historyProcessing = useRef<boolean>(false)
    const [historyUndo, setHistoryUndo] = useState<DiagramSpec[]>([])
    const [historyRedo, setHistoryRedo] = useState<DiagramSpec[]>([])
    const [diagramInfoPanelVisible, setDiagramInfoPanelVisible] =
      useState(false)
    const [diagramRenderer, setDiagramRenderer] = useState<
      DiagramRenderer | undefined
    >()
    const { modal, showModal, hideModal } = useModal()

    // Before checking if the diagram has been changed, we need to exclude the
    // "auto_layout" property which contains the auto generated positions.
    // We have to exclude this property because it is auto generated and it could
    // change after each rendering even if the user has not changed the diagram.
    // If the user has not changed the diagram, but just the auto layout has been
    // changed, we don't need to rerender the diagram.
    let currDiagram = currentRenderedDiagram.current
    let newDiagram = diagram
    if (currDiagram) {
      const { auto_layout, ...currDiagramNoAutoLayout } = currDiagram
      currDiagram = currDiagramNoAutoLayout
    }
    if (newDiagram) {
      const { auto_layout, ...newDiagramNoAutoLayout } = newDiagram
      newDiagram = newDiagramNoAutoLayout
    }
    if (!objectsAreEqual(currDiagram, newDiagram)) {
      currentRenderedDiagram.current = diagram
    }

    function canvasModifiedCallback() {
      isDiagramChanged.current = true
      if (!readOnly) saveHistory()
    }

    function createCanvas(canvasState?: KeadexCanvasState) {
      const options: KeadexCanvasOptions = {
        fireRightClick: true,
        fireMiddleClick: true,
        stopContextMenu: true,
        backgroundColor: 'white',
        readOnly: props.readOnly,
        enableSnapToGrid: true,
      }

      const localCanvas = new KeadexCanvas(canvasEl.current, options)

      localCanvas.on(CANVAS_EVENTS.OBJECT_ADDED, canvasModifiedCallback)
      localCanvas.on(CANVAS_EVENTS.OBJECT_REMOVED, canvasModifiedCallback)
      localCanvas.on(CANVAS_EVENTS.OBJECT_MODIFIED, canvasModifiedCallback)

      localCanvas.on(
        CANVAS_EVENTS.MOUSE_DOWN,
        () => (mouseOnCanvas.current = true),
      )
      localCanvas.on(
        CANVAS_EVENTS.MOUSE_OUT,
        () => (mouseOnCanvas.current = false),
      )

      localCanvas.codingFeaturesEnabled = props.target === 'desktop'

      isDiagramChanged.current = false

      // Reset the state of the canvas (if any)
      if (canvasState) {
        localCanvas.setZoom(canvasState.zoom)
        localCanvas.relativePan(
          new fabric.Point(canvasState.pan.panX, canvasState.pan.panY),
        )
      }
      canvas.current = localCanvas
    }

    function destroyCanvas() {
      if (canvas.current) {
        canvas.current.dispose()
        canvas.current = undefined
      }
    }

    function resetCanvas(canvasState?: KeadexCanvasState) {
      destroyCanvas()
      createCanvas(canvasState)
    }

    function getCanvasState(): KeadexCanvasState {
      return {
        zoom: canvas.current?.getZoom() ?? 1,
        pan: getCanvasPan(canvas.current),
      }
    }

    async function exportDiagram() {
      if (
        currentRenderedDiagram.current?.diagram_name &&
        currentRenderedDiagram.current.diagram_type &&
        canvas.current
      ) {
        const format = 'png' //TODO
        console.debug(`Exporting to ${format}`)

        // Temporary reset the viewport transform in order to ignore zoom and pan
        // in the exported diagram.
        const originalTransform = canvas.current.viewportTransform
        canvas.current.viewportTransform = fabric.iMatrix.slice(0)

        // Calculate the bounding box of all the objects of the canvas in order to
        // export also the objects "outside" the canvas and not visible in the viewport
        let { width, height, left, top } = getBoundingBox(
          canvas.current.getObjects(),
        )
        if (width && height && left && top) {
          width += MARGIN_EXPORTED_DIAGRAM
          height += MARGIN_EXPORTED_DIAGRAM
          left -= MARGIN_EXPORTED_DIAGRAM / 2
          top -= MARGIN_EXPORTED_DIAGRAM / 2
        }

        await exportDiagramToFile(
          currentRenderedDiagram.current.diagram_name,
          currentRenderedDiagram.current.diagram_type,
          canvas.current.toDataURL({
            format,
            enableRetinaScaling: true,
            width,
            height,
            left,
            top,
          }),
          format,
        )
          .then((pathExportedDiagram) =>
            toast.success(
              t('common.info.diagram_exported', { pathExportedDiagram }),
            ),
          )
          .catch((error: MinaError) => toast.success(error.msg))

        // Restore the original viewport transform (with zoom and pan)
        canvas.current.viewportTransform = originalTransform
      }
    }

    function getUpdatedDiagramSpec(): DiagramSpec | undefined {
      if (
        currentRenderedDiagram.current &&
        currentRenderedDiagram.current.diagram_plantuml &&
        currentRenderedDiagram.current.diagram_spec &&
        currentRenderedDiagram.current.diagram_name &&
        currentRenderedDiagram.current.diagram_type
      ) {
        const autoLayoutEnabled =
          canvas.current?.autoLayoutEnabled !== undefined
            ? canvas.current.autoLayoutEnabled
            : currentRenderedDiagram.current.diagram_spec.auto_layout_enabled

        let updatedSpecs: DiagramElementSpec[] = []
        if (!autoLayoutEnabled) {
          updatedSpecs = updateDiagramElementsSpecsFromCanvas(canvas.current)
        }

        return {
          ...currentRenderedDiagram.current.diagram_spec,
          auto_layout_enabled: autoLayoutEnabled,
          auto_layout_orientation:
            canvas.current?.autoLayoutOrientation !== undefined
              ? canvas.current.autoLayoutOrientation
              : currentRenderedDiagram.current.diagram_spec
                  .auto_layout_orientation,
          elements_specs: updatedSpecs,
        }
      }
    }

    function isDiagramChangedFunc(): boolean {
      return isDiagramChanged.current
    }

    function isAutoLayoutEnabled(): boolean {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec.auto_layout_enabled
      else return false
    }

    function autoLayoutOrientation(): DiagramOrientation {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec
          .auto_layout_orientation
      else return 'TopToBottom'
    }

    function isGenerateOnlyStraightArrowsEnabled(): boolean {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec
          .auto_layout_only_straight_arrows
      else return false
    }

    function ranksep(): number {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec.auto_layout_ranksep
      else return 0
    }

    function subgraphInnerMargin(): number {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec
          .auto_layout_subgraph_inner_margin
      else return DEFAULT_SUBGRAPH_INNER_MARGIN
    }

    function subgraphOuterMargin(): number {
      if (currentRenderedDiagram.current?.diagram_spec)
        return currentRenderedDiagram.current.diagram_spec
          .auto_layout_subgraph_outer_margin
      else return DEFAULT_SUBGRAPH_OUTER_MARGIN
    }

    function updateAutoLayoutOptions(
      enabled: boolean,
      orientation: DiagramOrientation,
      generateOnlyStraightArrows: boolean,
      ranksep: number,
      subgraphInnerMargin: number,
      subgraphOuterMargin: number,
    ) {
      if (canvas.current && currentRenderedDiagram.current && !readOnly) {
        showModal({
          id: `showAutoLayoutConfigurationModal`,
          title: `${t('diagram_editor.configure_auto_layout')}`,
          body: (
            <ModalAutoLayout
              enabled={enabled}
              orientation={orientation}
              generateOnlyStraightArrows={generateOnlyStraightArrows}
              ranksep={ranksep}
              subgraphInnerMargin={subgraphInnerMargin}
              subgraphOuterMargin={subgraphOuterMargin}
              hideModal={hideModal}
              onAutoLayoutConfigured={(
                enabled,
                orientation,
                generateOnlyStraightArrows,
                ranksep,
                subgraphInnerMargin,
                subgraphOuterMargin,
              ) => {
                if (
                  canvas.current &&
                  currentRenderedDiagram.current &&
                  !readOnly
                ) {
                  canvas.current.autoLayoutEnabled = enabled
                  canvas.current.autoLayoutOrientation = orientation

                  // On saving, diagram_spec are retrieved from the DiagramDesignView
                  // (check handleSaveDiagram() in DiagramEditor). So it's ok changing the
                  // "auto_layout_only_straight_arrows" property here.
                  if (currentRenderedDiagram.current.diagram_spec) {
                    currentRenderedDiagram.current.diagram_spec.auto_layout_only_straight_arrows =
                      generateOnlyStraightArrows
                    currentRenderedDiagram.current.diagram_spec.auto_layout_ranksep =
                      ranksep
                    currentRenderedDiagram.current.diagram_spec.auto_layout_subgraph_inner_margin =
                      subgraphInnerMargin
                    currentRenderedDiagram.current.diagram_spec.auto_layout_subgraph_outer_margin =
                      subgraphOuterMargin
                  }

                  isDiagramChanged.current = true
                  if (saveDiagram) saveDiagram()
                }
              }}
            />
          ),
          buttons: false,
        })
      }
    }

    function diagramDesignViewSettings():
      | DiagramDesignViewSettings
      | undefined {
      if (currentRenderedDiagram.current?.diagram_spec) {
        return {
          gridEnabled: currentRenderedDiagram.current.diagram_spec.grid_enabled,
        }
      }
    }

    function updateDiagramDesignViewSettings(
      settings?: DiagramDesignViewSettings,
    ) {
      if (
        settings &&
        canvas.current &&
        currentRenderedDiagram.current &&
        !readOnly
      ) {
        showModal({
          id: `showDiagramDesignViewSettingsModal`,
          title: `${t('common.settings')}`,
          body: (
            <ModalDiagramDesignViewSettings
              settings={settings}
              hideModal={hideModal}
              onSettingsChanged={(settings) => {
                if (
                  canvas.current &&
                  currentRenderedDiagram.current &&
                  !readOnly
                ) {
                  if (settings.gridEnabled) {
                    canvas.current.enableGrid()
                  } else {
                    canvas.current.disableGrid()
                  }

                  // On saving, diagram_spec are retrieved from the DiagramDesignView
                  // (check handleSaveDiagram() in DiagramEditor). So it's ok changing the
                  // settings here.
                  if (currentRenderedDiagram.current.diagram_spec)
                    currentRenderedDiagram.current.diagram_spec.grid_enabled =
                      settings.gridEnabled ?? false

                  isDiagramChanged.current = true
                  if (saveDiagram) saveDiagram()
                }
              }}
            />
          ),
          buttons: false,
        })
      }
    }

    function setCanvasMode() {
      if (
        currentRenderedDiagram.current?.diagram_spec &&
        canvas.current &&
        !props.readOnly
      ) {
        if (currentRenderedDiagram.current?.diagram_spec.auto_layout_enabled) {
          canvas.current.setReadOnly()
        } else {
          canvas.current.setReadAndWrite()
        }
      }
    }

    //----------------- Start History Implementation
    function initHistory() {
      // console.debug('Init history')
      historyProcessing.current = false
      if (currentRenderedDiagram.current?.diagram_spec) {
        setHistoryUndo([currentRenderedDiagram.current.diagram_spec])
      }
      setHistoryRedo([])
    }

    function saveHistory() {
      if (!historyProcessing.current) {
        const updatedSpecs = getUpdatedDiagramSpec()
        if (updatedSpecs) {
          // console.debug('Save history')
          setHistoryUndo((prev) => [...prev, updatedSpecs])
        }
      }
    }

    function loadHistory(history: DiagramSpec) {
      // console.debug('Load history')
      if (canvas.current) {
        resetCanvas(getCanvasState())
        setCanvasMode()
        if (diagramRenderer)
          diagramRenderer.renderDiagram(
            canvas.current,
            diagramListener,
            {
              ...currentRenderedDiagram.current,
              diagram_spec: history,
            },
            diagramsThemeSettings,
          )
        else console.error('DiagramRenderer not initialized')

        canvas.current?.renderAll()
        isDiagramChanged.current = true
        console.debug('Load history completed')
      }
    }

    function undo() {
      historyProcessing.current = true
      // In the stack there should be alway at least 2 elements: the current state, just pushed,
      // due to the modified object, and the previous one that we want to restore
      if (canUndo()) {
        const currentState = historyUndo[historyUndo.length - 1]
        const previousState = historyUndo[historyUndo.length - 2]
        // setHistoryUndo((prev) => prev.slice(0, prev.length - 2))
        if (currentRenderedDiagram.current && currentState && previousState) {
          console.debug('Undo design view')
          // "pop" from the history only the old current state and keep the previous state,
          // which is the new one we're going to restore
          setHistoryUndo((prev) =>
            prev.filter((value, index) => index !== prev.length - 1),
          )
          // "push" the current state to the redo history
          setHistoryRedo((prev) => [...prev, currentState])

          loadHistory(previousState)
        }
      }
      historyProcessing.current = false
    }

    function redo() {
      console.debug('Redo design view')
      historyProcessing.current = true
      if (canRedo()) {
        const nextState = historyRedo[historyRedo.length - 1]
        if (nextState) {
          // "pop"
          setHistoryRedo((prev) =>
            prev.filter((value, index) => index !== prev.length - 1),
          )
          // Re-"push" the next state we're going to restore in the undo history
          // since it is the new current state
          setHistoryUndo((prev) => [...prev, nextState])

          loadHistory(nextState)
        }
      }
      historyProcessing.current = false
    }

    function canUndo(): boolean {
      return !readOnly && historyUndo.length > 1
    }

    function canRedo(): boolean {
      return !readOnly && historyRedo.length > 0
    }
    //----------------- End History Implementation

    useImperativeHandle(ref, () => ({
      resetCanvas,
      getCanvasState,
      exportDiagram,
      getUpdatedDiagramSpec,
      isDiagramChanged: isDiagramChangedFunc,
      undo,
      redo,
      canUndo,
      canRedo,
      isAutoLayoutEnabled,
      autoLayoutOrientation,
      updateAutoLayoutOptions,
      isGenerateOnlyStraightArrowsEnabled,
      ranksep,
      updateDiagramDesignViewSettings,
      diagramDesignViewSettings,
      subgraphInnerMargin,
      subgraphOuterMargin,
    }))

    useLayoutEffect(() => {
      console.debug('Diagram Design View changed layout')
      if (
        canvasEl.current &&
        parentDivEl.current?.clientWidth &&
        parentDivEl.current?.clientHeight
      ) {
        console.debug('Canvas resize')
        // Following is needed because if you calculate the new height without hiding
        // the inner canvas, it will have the full height of the div, which is not correct.
        // The real height takes also into account other divs before the canvas one.
        if (canvasEl.current.parentElement)
          canvasEl.current.parentElement.style.display = 'none'
        canvas.current?.setWidth(
          parentDivEl.current?.getBoundingClientRect().width,
        )
        canvas.current?.setHeight(
          parentDivEl.current?.getBoundingClientRect().height,
        )
        if (canvasEl.current.parentElement)
          canvasEl.current.parentElement.style.display = 'flex'
        canvas.current?.renderAll()
      }
    })

    useEffect(() => {
      // Make sure to rerender the canvas after loading the custom font, since
      // it could happen the font is not ready before rendering the canvas.
      // Without rerendering it, the canvas will render only the wrong font.
      const myfont = new FontFaceObserver(ELEMENT.FONT.FAMILY)
      myfont.load(null, 360000).then(function () {
        if (canvas.current) {
          invalidateCanvasCache(canvas.current)
          canvas.current.renderAll()
        }
      })
      if (canvasEl.current && !canvas.current) {
        createCanvas()
      }
      return () => {
        destroyCanvas()
      }
    }, [])

    useEffect(() => {
      function handle(e: KeyboardEvent) {
        if (
          !readOnly &&
          (e.key.toUpperCase() === 'Z' || e.key.toUpperCase() === 'Y') &&
          (e.ctrlKey || e.metaKey) &&
          mouseOnCanvas.current
        ) {
          e.preventDefault()
          if (e.key.toUpperCase() === 'Z') {
            undo()
          } else if (e.key.toUpperCase() === 'Y') {
            redo()
          }
        }
      }
      document.addEventListener('keydown', handle)
      return () => document.removeEventListener('keydown', handle)
    }, [readOnly, historyUndo, historyRedo])

    useEffect(() => {
      if (canvas.current && currentRenderedDiagram.current && diagramRenderer) {
        // Set history processing to true to avoid to save the history during the first rendering
        historyProcessing.current = true
        console.debug('Rendering the diagram')
        setCanvasMode()
        diagramRenderer.renderDiagram(
          canvas.current,
          diagramListener,
          currentRenderedDiagram.current,
          diagramsThemeSettings,
        )
        canvas.current?.renderAll()
        isDiagramChanged.current = false
        historyProcessing.current = false
        if (!readOnly) initHistory()
      }
    }, [currentRenderedDiagram.current, diagramRenderer])

    useEffect(() => {
      if (!readOnly && diagramDesignViewToolbarCommands) {
        console.debug('Update design toolbar')
        diagramDesignViewToolbarCommands.current?.forceUpdate()
      }
    }, [readOnly, historyUndo, historyRedo, diagramDesignViewToolbarCommands])

    useEffect(() => {
      async function initDiagramRenderer() {
        const renderer = await new DiagramRenderer().initialize()
        setDiagramRenderer(renderer)
      }
      initDiagramRenderer()
    }, [])

    useHotkeys([Key.Escape], (e) => {
      if (canvas.current) {
        e.preventDefault()
        canvas.current?.discardActiveObject()
      }
    })

    return (
      <div className="relative h-full w-full" ref={rootDiv}>
        {modal}
        <DiagramDesignViewFloatMenu
          canvas={canvas.current}
          readOnly={readOnly}
          diagramInfoPanelVisible={diagramInfoPanelVisible}
          setDiagramInfoPanelVisible={setDiagramInfoPanelVisible}
        />
        <DiagramInfoPanel
          diagram={diagram}
          hidden={!diagramInfoPanelVisible}
          setDiagramInfoPanelVisible={setDiagramInfoPanelVisible}
        />
        <div className="h-full w-full flex-row flex-wrap" ref={parentDivEl}>
          <canvas ref={canvasEl} />
        </div>
      </div>
    )
  },
)

export default DiagramDesignView
