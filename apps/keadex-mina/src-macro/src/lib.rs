use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use std::collections::HashMap;
use std::vec;
use syn::parse::Parser;
use syn::punctuated::Punctuated;
use syn::{parse_macro_input, token::Comma, FnArg, ItemFn, Pat, ReturnType, Type};
use syn::{Expr, ExprCall};

const WITHOUT_INPUT_TRANSFORMATION_ARG: &str = "without_input_transformation";

fn extract_result_types(return_type: &ReturnType) -> (&Type, &Type) {
  if let ReturnType::Type(_, type_box) = return_type {
    if let Type::Path(type_path) = &**type_box {
      // Ensure it's a Result<T, E>
      if let Some(seg) = type_path.path.segments.last() {
        if seg.ident == "Result" {
          if let syn::PathArguments::AngleBracketed(args) = &seg.arguments {
            if args.args.len() == 2 {
              if let syn::GenericArgument::Type(success_type) = &args.args[0] {
                if let syn::GenericArgument::Type(error_type) = &args.args[1] {
                  return (success_type, error_type);
                }
              }
            }
          }
        }
      }
    }
  }
  panic!("Web Controller must return a Result<T,E>")
}

fn extract_params(
  args: &syn::punctuated::Punctuated<FnArg, Comma>,
) -> (Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>) {
  let mut params_name = vec![];
  let mut params_type = vec![];
  args.iter().for_each(|arg| {
    match arg {
      FnArg::Typed(pat_type) => {
        if let Pat::Ident(ident) = &*pat_type.pat {
          let param_name = &ident.ident;
          let param_type = &pat_type.ty;
          params_name.push(quote! { #param_name });
          params_type.push(quote! { #param_type });
        }
      }
      _ => {} // Skip `self` for methods
    }
  });
  return (params_name, params_type);
}

fn extract_args(
  args: syn::punctuated::Punctuated<Expr, Comma>,
) -> HashMap<String, Option<Vec<String>>> {
  let mut filtered_args = HashMap::<String, Option<Vec<String>>>::new();
  for arg in &args {
    if let Expr::Call(ExprCall {
      func,
      args: inner_args,
      ..
    }) = arg
    {
      // This is an argument with inner arguments (e.g., "without_input_transformation(inner_arg1, inner_arg2))"

      // Check if the function is an identifier (e.g., "without_input_transformation")
      if let Expr::Path(func_path) = func.as_ref() {
        if let Some(ident) = func_path.path.get_ident() {
          let func_name = ident.to_string();

          // Process the inner arguments (e.g., "inner_arg1" and "inner_arg2")
          let mut parsed_inner_args = vec![];
          for inner_arg in inner_args {
            if let Expr::Path(inner_arg_path) = inner_arg {
              if let Some(inner_ident) = inner_arg_path.path.get_ident() {
                parsed_inner_args.push(inner_ident.to_string());
              }
            }
          }

          if filtered_args.contains_key(&func_name) {
            panic!(
              "Cannot specify same argument \"{}\" several times",
              func_name
            )
          } else {
            filtered_args.insert(func_name, Some(parsed_inner_args));
          }
        }
      }
    } else if let Expr::Path(path) = arg {
      // This is an argument without inner arguments (e.g., "without_input_transformation")
      let func_name = path.path.get_ident().unwrap().to_string();
      if filtered_args.contains_key(&func_name) {
        panic!(
          "Cannot specify same argument \"{}\" several times",
          func_name
        )
      } else {
        filtered_args.insert(func_name, None);
      }
    }

    // filtered_args.push(arg.to_token_stream().to_string());
  }
  if filtered_args.len() > 0
    && !filtered_args.contains_key(&WITHOUT_INPUT_TRANSFORMATION_ARG.to_string())
  {
    panic!("Invalid macro arguments")
  }
  return filtered_args;
}

/// An attribute macro that transforms a Rust function into a JavaScript-callable function.
/// This macro returns an asynchronous function that invokes the original function
/// and converts the success value into a wasm_bindgen::JsValue.
/// It leverages the wasm_bindgen and serde_wasm_bindgen crates,
/// making it useful when you need to return plain JavaScript objects (wasm_bindgen::JsValue
/// generated by serde_wasm_bindgen) instead of JavaScript classes generated by wasm_bindgen.
/// This macro expects a function that returns a Result<T, E>.
#[proc_macro_attribute]
pub fn web_controller(attr: TokenStream, item: TokenStream) -> TokenStream {
  // Parse the macro args
  let args = extract_args(
    Punctuated::<Expr, Comma>::parse_terminated
      .parse(attr)
      .unwrap(),
  );

  // Parse the input tokens as a function
  let input_fn = parse_macro_input!(item as ItemFn);

  // Extract function components
  let vis = &input_fn.vis;
  let fn_name = &input_fn.sig.ident;
  let fn_args = &input_fn.sig.inputs;
  let fn_block = &input_fn.block;
  let return_type = &input_fn.sig.output;
  let (success_type, error_type) = extract_result_types(return_type);
  let (param_names, param_types) = extract_params(fn_args);
  let return_type_string = success_type.to_token_stream().to_string();

  let mut transformed_fn_args = vec![];
  let mut jsvalue_to_obj_stmts = vec![];
  let mut params_to_ignore: &Option<Vec<String>> = &None;

  if args.contains_key(&WITHOUT_INPUT_TRANSFORMATION_ARG.to_string()) {
    params_to_ignore = args
      .get(&WITHOUT_INPUT_TRANSFORMATION_ARG.to_string())
      .unwrap();
  }

  for (index, _fn_arg) in fn_args.iter().enumerate() {
    let param_name = param_names.get(index).unwrap();
    let param_type = param_types.get(index).unwrap();
    let param_type_string = format!("{}", param_type).replace(" ", "");

    if !args.contains_key(&WITHOUT_INPUT_TRANSFORMATION_ARG.to_string())
      || (args.contains_key(&WITHOUT_INPUT_TRANSFORMATION_ARG.to_string())
        && (params_to_ignore.is_some()
          && !params_to_ignore
            .as_ref()
            .unwrap()
            .contains(&param_name.to_string())))
    {
      transformed_fn_args.push(quote! {
        #[wasm_bindgen::prelude::wasm_bindgen(unchecked_param_type = #param_type_string)]
        #param_name: wasm_bindgen::JsValue
      });
      jsvalue_to_obj_stmts.push(quote! {
              let #param_name: #param_type = serde_wasm_bindgen::from_value(wasm_bindgen::JsValue::from(#param_name)).unwrap();
            });
    } else {
      transformed_fn_args.push(quote! {
        #param_name: #param_type
      });
    }
  }

  let new_fn_args = quote! { #( #transformed_fn_args ),* };
  let new_fn_jsvalue_to_obj_stmts = quote! { #( #jsvalue_to_obj_stmts );* };

  // Generate an async function that wraps the original one and transforms
  // its success value into a wasm_bindgen::JsValue
  let expanded = quote! {
      #[wasm_bindgen::prelude::wasm_bindgen(unchecked_return_type = #return_type_string)]
      #vis async fn #fn_name(#new_fn_args) -> Result<wasm_bindgen::JsValue, #error_type> {
          async fn original(#fn_args) #return_type #fn_block

          #new_fn_jsvalue_to_obj_stmts
          let value = original(#( #param_names ),*).await?;

          use serde::Serialize;
          let serializer = serde_wasm_bindgen::Serializer::new().serialize_maps_as_objects(true);
          Ok(value.serialize(&serializer)?)
      }
  };

  TokenStream::from(expanded)
}
