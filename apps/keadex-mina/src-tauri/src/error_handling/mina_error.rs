use crate::error_handling::errors::{
  GENERIC_ERROR_MSG, INVALID_PLANTUML_ERROR_CODE, IO_ERROR_CODE, OPENAI_ERROR_CODE,
  SERDE_PARSING_ERROR_CODE, SERDE_SERIALIZE_ERROR_CODE, STRUM_PARSING_ERROR_CODE,
  WALKDIR_ERROR_CODE, WASM_ERROR_CODE,
};
use crate::parser::plantuml::plantuml_parser::Rule;
use async_openai_wasm::error::OpenAIError;
use serde::{Deserialize, Serialize};
use std::fmt;
use ts_rs::TS;
use wasm_bindgen::prelude::wasm_bindgen;
use wasm_bindgen::JsCast;

/**
Error exposed to the front-end.
It can be created starting from other errors.
*/
#[derive(TS)]
#[ts(
  export,
  export_to = "../../../apps/keadex-mina/src/models/autogenerated/"
)]
#[derive(Default, Serialize, Deserialize, Clone, Debug)]
#[wasm_bindgen(getter_with_clone)]
pub struct MinaError {
  pub code: i32,
  pub msg: String,
}

impl MinaError {
  pub fn new(code: i32, msg: &str) -> Self {
    Self {
      code,
      msg: format!("{} (error code: {})", msg, code),
    }
  }
}

impl fmt::Display for MinaError {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(f, "{}", self.msg)
  }
}

//---- Implementations From trait

impl From<std::io::Error> for MinaError {
  fn from(err: std::io::Error) -> MinaError {
    MinaError::new(IO_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<pest::error::Error<Rule>> for MinaError {
  fn from(err: pest::error::Error<Rule>) -> MinaError {
    MinaError::new(INVALID_PLANTUML_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<strum::ParseError> for MinaError {
  fn from(err: strum::ParseError) -> MinaError {
    MinaError::new(STRUM_PARSING_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<serde_json::Error> for MinaError {
  fn from(err: serde_json::Error) -> MinaError {
    MinaError::new(SERDE_PARSING_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<serde_wasm_bindgen::Error> for MinaError {
  fn from(err: serde_wasm_bindgen::Error) -> MinaError {
    MinaError::new(SERDE_SERIALIZE_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<OpenAIError> for MinaError {
  fn from(err: OpenAIError) -> MinaError {
    MinaError::new(OPENAI_ERROR_CODE, err.to_string().as_str())
  }
}

#[cfg(desktop)]
impl From<walkdir::Error> for MinaError {
  fn from(err: walkdir::Error) -> MinaError {
    MinaError::new(WALKDIR_ERROR_CODE, err.to_string().as_str())
  }
}

impl From<wasm_bindgen::JsValue> for MinaError {
  fn from(err: wasm_bindgen::JsValue) -> MinaError {
    let message;
    if err.as_ref().is_instance_of::<js_sys::Error>() {
      message = err
        .dyn_into::<js_sys::Error>()
        .unwrap()
        .message()
        .as_string()
        .unwrap();
    } else {
      message = err.as_string().unwrap_or(String::from(GENERIC_ERROR_MSG));
    }
    MinaError::new(WASM_ERROR_CODE, &message)
  }
}
