/*!
Project Repository.
Module which exposes functions to access/alter project's data.
Under the hood it uses DAOs.
*/

use std::path::Path;

use crate::core::app::ROOT_RESOLVER;
use crate::core::resolver::ResolvableModules::{ProjectSettingsFsDAO, ProjectSettingsIMDAO};
use crate::dao::filesystem::FileSystemDAO;
use crate::dao::inmemory::InMemoryDAO;
use crate::error_handling::mina_error::MinaError;
use crate::helper::project_helper::project_settings_path;
use crate::model::project_settings::ProjectSettings;
use crate::resolve_to_write;

pub async fn save_project_settings(
  updated_project_settings: ProjectSettings,
) -> Result<ProjectSettings, MinaError> {
  let store = ROOT_RESOLVER.get().read().await;
  let stored_project_settings = resolve_to_write!(store, ProjectSettingsIMDAO)
    .await
    .get()
    .await
    .unwrap();

  // Make sure path of the root's project has not been altered
  let patched_project_settings = Some(ProjectSettings {
    root: stored_project_settings.root.clone(),
    ..updated_project_settings
  });

  // Update project settings in memory state
  resolve_to_write!(store, ProjectSettingsIMDAO)
    .await
    .save(&patched_project_settings)
    .await;

  // Update project settings in fs

  // Before saving the project settings in fs, replace the real root with a static placehodler.
  // The root must not be saved in the file system, because it is relative
  // to the user's machine and it cannot be versioned.
  let project_settings_no_root = ProjectSettings {
    root: String::from("<autogenerated>"),
    ..patched_project_settings.unwrap()
  };

  resolve_to_write!(store, ProjectSettingsFsDAO)
    .await
    .save(
      &project_settings_no_root,
      Path::new(&project_settings_path(&stored_project_settings.root)),
      false,
    )
    .await?;

  let updated_project_settings = resolve_to_write!(store, ProjectSettingsIMDAO)
    .await
    .get()
    .await
    .unwrap();
  Ok(updated_project_settings)
}
