/*!
Graph Render Backend.
Module which exposes the backend to store the positions generated by the Layout library during the rendering process.
*/

use crate::model::graph::element_data::ElementData;
use crate::model::graph::point::Point;
use layout::core::{
  format::{ClipHandle, RenderBackend},
  geometry::Point as LayoutPoint,
  style::StyleAttr,
};
use serde::{Deserialize, Serialize};
use std::{borrow::BorrowMut, collections::HashMap};
use ts_rs::TS;

pub const GRAPH_PADDING: f64 = 30.;

#[derive(TS, Serialize, Deserialize, Debug, Clone)]
pub struct GraphRenderBackend {
  pub elements: HashMap<String, ElementData>,
  pub x: f64,
  pub y: f64,
  width: f64,
  heigth: f64,
  temp_element_data: Option<ElementData>,
  temp_edges_aliases: Vec<String>,
}

impl Default for GraphRenderBackend {
  fn default() -> Self {
    Self {
      elements: HashMap::<String, ElementData>::new(),
      x: f64::MAX,
      y: f64::MAX,
      width: -1.0,
      heigth: -1.0,
      temp_element_data: None,
      temp_edges_aliases: vec![],
    }
  }
}

impl GraphRenderBackend {
  /**
  Updates the overall graph position and size according to the given position
  and size of an internal element.
  If the given element is outside the current graph boundaries, the they will be updated.
  # Arguments
    * `xy` - Position of a graph element.
    * `size` - Size of a graph element.
  */
  fn update_graph_size(&mut self, xy: Option<Point>, size: Option<Point>) {
    if let Some(xy) = xy {
      if self.x > xy.x {
        self.x = xy.x
      }
      if self.y > xy.y {
        self.y = xy.y
      }
      if let Some(size) = size {
        if (xy.x + size.x) > self.width {
          self.width = xy.x + size.x
        }
        if (xy.y + size.y) > self.heigth {
          self.heigth = xy.y + size.y
        }
      }
    }
  }

  /**
  Returns the width of graph.
  */
  pub fn get_width(&self) -> f64 {
    return self.width - self.x;
  }

  /**
  Returns the height of graph.
  */
  pub fn get_height(&self) -> f64 {
    return self.heigth - self.y;
  }

  /**
  Recalculates the positions of all the graph elements by using the given offsets (x and y).
  # Arguments
    * `offset_x` - Offset x.
    * `offset_y` - Offset y.
  */
  pub fn adjust_positions(&mut self, offset_x: f64, offset_y: f64) {
    for element in self.elements.borrow_mut() {
      if let Some(position) = element.1.position.borrow_mut() {
        position.x = position.x + offset_x - GRAPH_PADDING;
        position.y = position.y + offset_y - GRAPH_PADDING;
      }
      if let Some(start) = element.1.start.borrow_mut() {
        start.x = start.x + offset_x - GRAPH_PADDING;
        start.y = start.y + offset_y - GRAPH_PADDING;
      }
      if let Some(end) = element.1.end.borrow_mut() {
        end.x = end.x + offset_x - GRAPH_PADDING;
        end.y = end.y + offset_y - GRAPH_PADDING;
      }
    }
  }
}

impl RenderBackend for GraphRenderBackend {
  fn draw_rect(
    &mut self,
    raw_xy: LayoutPoint,
    size: LayoutPoint,
    _look: &StyleAttr,
    _clip: Option<ClipHandle>,
  ) {
    let xy = Point::from(raw_xy);

    self.temp_element_data = Some(ElementData::new(
      Some(xy),
      None,
      None,
      Some(Point::from(size)),
    ));

    self.update_graph_size(Some(xy), Some(Point::from(size)));

    // println!("canvas.add(new fabric.Rect({{ width: {}, height: {}, fill: '{}', left: {}, top: {} }}))", size.x, size.y, color, xy.x, xy.y);
  }

  fn draw_arrow(
    &mut self,
    raw_path: &[(LayoutPoint, LayoutPoint)],
    _dashed: bool,
    head: (bool, bool),
    _look: &StyleAttr,
    _text: &str,
  ) {
    let mut start = Point::from(raw_path[0].0);
    let mut end = Point::from(raw_path[raw_path.len() - 1].1);
    if head.1 {
      start = Point::from(raw_path[raw_path.len() - 1].1);
      end = Point::from(raw_path[0].0);
    };

    self.elements.insert(
      String::from(&self.temp_edges_aliases[0]),
      ElementData::new(None, Some(start), Some(end), None),
    );

    self.temp_edges_aliases.remove(0);

    // No need to update the graph size in the case of edges, since they cannot be outside the graph boundaries

    // println!(
    //   "canvas.add(new fabric.Line([{}, {}, {}, {}], {{ fill: '{}', stroke: '{}', strokeWidth: 2 }}))",
    //   path[0].0.x, path[0].0.y, path[path.len()-1].1.x, path[path.len()-1].1.y, color, color
    // );
  }

  fn draw_text(&mut self, _raw_xy: LayoutPoint, text: &str, _look: &StyleAttr) {
    if let Some(temp_element_data) = self.temp_element_data.clone() {
      self.elements.insert(String::from(text), temp_element_data);
    } else {
      self.temp_edges_aliases.push(String::from(text));
    }
    self.temp_element_data = None;

    // let xy = Point::new(raw_xy.x, raw_xy.y);
    // println!(
    //   "canvas.add(new fabric.Text('{}', {{ fill: 'black', left: {}, top: {}, fontSize: 20 }}))",
    //   text, xy.x, xy.y
    // )
  }

  fn draw_line(&mut self, _start: LayoutPoint, _stop: LayoutPoint, _look: &StyleAttr) {
    // do nothing - unused
  }

  fn draw_circle(&mut self, _xy: LayoutPoint, _size: LayoutPoint, _look: &StyleAttr) {
    // do nothing - unused
  }

  fn create_clip(
    &mut self,
    _xy: LayoutPoint,
    _size: LayoutPoint,
    _rounded_px: usize,
  ) -> ClipHandle {
    // do nothing - unused
    return 0;
  }
}
