/*!
Model representing a Relationship between two C4 entities.
*/

use crate::core::serializer::format_with_indent;
use crate::helper::relationship_helper::generate_relationship_alias;
use crate::model::{
  c4_element::base_element::BaseElement, diagram::diagram_plantuml::PlantUMLSerializer,
};
use crate::parser::plantuml::plantuml_parser::Rule;
use bomboni_wasm::Wasm;
use pest::error::Error;
use pest::iterators::Pair;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use strum_macros::{Display, EnumIter, EnumString};
use ts_rs::TS;
use wasm_bindgen::prelude::wasm_bindgen;

#[derive(TS)]
#[ts(
  export,
  export_to = "../../../libs/c4-model-ui-kit/src/models/autogenerated/"
)]
#[derive(Serialize, Deserialize, Display, Debug, EnumString, EnumIter, Clone, PartialEq, Wasm)]
#[wasm(wasm_abi)]
pub enum RelationshipType {
  #[serde(rename = "Rel_Neighbor")]
  #[strum(serialize = "Rel_Neighbor")]
  RelNeighbor,
  #[serde(rename = "Rel_Back_Neighbor")]
  #[strum(serialize = "Rel_Back_Neighbor")]
  RelBackNeighbor,
  #[serde(rename = "Rel_Back")]
  #[strum(serialize = "Rel_Back")]
  RelBack,
  #[serde(rename = "Rel_Down")]
  #[strum(serialize = "Rel_Down")]
  RelDown,
  #[serde(rename = "Rel_D")]
  #[strum(serialize = "Rel_D")]
  RelD,
  #[serde(rename = "Rel_Up")]
  #[strum(serialize = "Rel_Up")]
  RelUp,
  #[serde(rename = "Rel_U")]
  #[strum(serialize = "Rel_U")]
  RelU,
  #[serde(rename = "Rel_Left")]
  #[strum(serialize = "Rel_Left")]
  RelLeft,
  #[serde(rename = "Rel_L")]
  #[strum(serialize = "Rel_L")]
  RelL,
  #[serde(rename = "Rel_Right")]
  #[strum(serialize = "Rel_Right")]
  RelRight,
  #[serde(rename = "Rel_R")]
  #[strum(serialize = "Rel_R")]
  RelR,
  #[serde(rename = "Rel")]
  #[strum(serialize = "Rel")]
  Rel,
  #[serde(rename = "BiRel_Neighbor")]
  #[strum(serialize = "BiRel_Neighbor")]
  BiRelNeighbor,
  #[serde(rename = "BiRel_Down")]
  #[strum(serialize = "BiRel_Down")]
  BiRelDown,
  #[serde(rename = "BiRel_D")]
  #[strum(serialize = "BiRel_D")]
  BiRelD,
  #[serde(rename = "BiRel_Up")]
  #[strum(serialize = "BiRel_Up")]
  BiRelUp,
  #[serde(rename = "BiRel_U")]
  #[strum(serialize = "BiRel_U")]
  BiRelU,
  #[serde(rename = "BiRel_Left")]
  #[strum(serialize = "BiRel_Left")]
  BiRelLeft,
  #[serde(rename = "BiRel_L")]
  #[strum(serialize = "BiRel_L")]
  BiRelL,
  #[serde(rename = "BiRel_Right")]
  #[strum(serialize = "BiRel_Right")]
  BiRelRight,
  #[serde(rename = "BiRel_R")]
  #[strum(serialize = "BiRel_R")]
  BiRelR,
  #[serde(rename = "BiRel")]
  #[strum(serialize = "BiRel")]
  BiRel,
}

#[derive(TS)]
#[ts(
  export,
  export_to = "../../../libs/c4-model-ui-kit/src/models/autogenerated/"
)]
#[derive(Serialize, Deserialize, Debug, Default, Clone)]
#[wasm_bindgen(getter_with_clone)]
pub struct Relationship {
  pub base_data: BaseElement,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub from: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub to: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub technology: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub relationship_type: Option<RelationshipType>,
}

impl<'i> TryFrom<Pair<'i, Rule>> for Relationship {
  type Error = Error<Rule>;

  fn try_from(pair: Pair<Rule>) -> Result<Self, Self::Error> {
    let mut relationship = Self::default();

    let cloned_pair = pair.clone();
    relationship.base_data = cloned_pair.try_into().unwrap();

    let items = pair.into_inner();
    for item in items {
      match item.as_rule() {
        Rule::stdlib_c4_dynamic_rel_types => {
          relationship.relationship_type = Some(RelationshipType::from_str(item.as_str()).unwrap())
        }
        Rule::stdlib_c4_from => {
          relationship.from = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_to => {
          relationship.to = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_techn => {
          relationship.technology = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        _ => {}
      }
    }
    relationship.base_data.alias = Some(generate_relationship_alias(
      &relationship.from.clone().unwrap(),
      &relationship.to.clone().unwrap(),
    ));

    Ok(relationship)
  }
}

impl PlantUMLSerializer for Relationship {
  fn serialize_to_plantuml(&self, level: usize) -> String {
    let mut relationship_ser = String::new();
    // Serialize "relationship type"
    if let Some(relationship_type) = &self.relationship_type {
      relationship_ser.push_str(&format!("{}(", relationship_type));
    }
    // Serialize "from"
    if let Some(from) = &self.from {
      relationship_ser.push_str(&format!("{}, ", from));
    }
    // Serialize "to"
    if let Some(to) = &self.to {
      relationship_ser.push_str(&format!("{}, ", to));
    }
    // Serialize "label"
    if let Some(label) = &self.base_data.label {
      relationship_ser.push_str(&format!("\"{}\"", label));
    }
    // Serialize "technology"
    if let Some(technology) = &self.technology {
      relationship_ser.push_str(&format!(", \"{}\"", technology));
    }
    // Serialize "description"
    if let Some(description) = &self.base_data.description {
      relationship_ser.push_str(&format!(", \"{}\"", description));
    }
    // Serialize "sprite"
    if let Some(sprite) = &self.base_data.sprite {
      relationship_ser.push_str(&format!(", $sprite=\"{}\"", sprite));
    }
    // Serialize "tags"
    if let Some(tags) = &self.base_data.tags {
      relationship_ser.push_str(&format!(", $tags=\"{}\"", tags));
    }
    // Serialize "link"
    if let Some(link) = &self.base_data.link {
      relationship_ser.push_str(&format!(", $link=\"{}\"", link));
    }
    relationship_ser.push_str(")");

    format_with_indent(level, relationship_ser)
  }
}
