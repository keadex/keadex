/*!
Model representing the C4-PlantUML AddElementTag() function.
*/

use crate::core::serializer::format_with_indent;
use crate::model::diagram::diagram_plantuml::PlantUMLSerializer;
use crate::parser::plantuml::plantuml_parser::Rule;
use bomboni_wasm::Wasm;
use pest::error::Error;
use pest::iterators::Pair;
use serde::{Deserialize, Serialize};
use strum_macros::{Display, EnumString};
use ts_rs::TS;
use wasm_bindgen::prelude::wasm_bindgen;

#[derive(TS)]
#[ts(
  export,
  export_to = "../../../libs/c4-model-ui-kit/src/models/autogenerated/"
)]
#[derive(Serialize, Deserialize, Display, Debug, EnumString, Clone, Wasm)]
#[wasm(wasm_abi)]
pub enum AddElementTagType {
  #[serde(rename = "AddElementTag")]
  #[strum(serialize = "AddElementTag")]
  AddElementTag,
}

#[derive(TS)]
#[ts(
  export,
  export_to = "../../../libs/c4-model-ui-kit/src/models/autogenerated/"
)]
#[derive(Serialize, Deserialize, Debug, Default, Clone)]
#[wasm_bindgen(getter_with_clone)]
pub struct AddElementTag {
  #[serde(skip_serializing_if = "Option::is_none")]
  pub tag: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub bg_color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub font_color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub border_color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub shadowing: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub shape: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub sprite: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub techn: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub legend_text: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub legend_sprite: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub border_style: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub border_thickness: Option<String>,
}

impl<'i> TryFrom<Pair<'i, Rule>> for AddElementTag {
  type Error = Error<Rule>;

  fn try_from(pair: Pair<Rule>) -> Result<Self, Self::Error> {
    let mut add_element_tag = Self::default();

    let items = pair.into_inner();
    for item in items {
      match item.as_rule() {
        Rule::stdlib_c4_tag => {
          add_element_tag.tag = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_bg_color => {
          add_element_tag.bg_color = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_font_color => {
          add_element_tag.font_color = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_border_color => {
          add_element_tag.border_color =
            Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_shadowing => {
          add_element_tag.shadowing = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_shape => {
          let shape = item.into_inner().next().unwrap();
          if shape.as_rule() == Rule::stdlib_c4_function {
            add_element_tag.shape = Some(shape.as_str().to_string());
          } else {
            add_element_tag.shape = Some(format!("\"{}\"", shape.as_str()));
          }
        }
        Rule::stdlib_c4_sprite => {
          add_element_tag.sprite = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_explicit_techn => {
          add_element_tag.techn = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_legend_text => {
          add_element_tag.legend_text = Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_legend_sprite => {
          add_element_tag.legend_sprite =
            Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        Rule::stdlib_c4_border_style => {
          let border_style = item.into_inner().next().unwrap();
          if border_style.as_rule() == Rule::stdlib_c4_function {
            add_element_tag.border_style = Some(border_style.as_str().to_string());
          } else {
            add_element_tag.border_style = Some(format!("\"{}\"", border_style.as_str()));
          }
        }
        Rule::stdlib_c4_border_thickness => {
          add_element_tag.border_thickness =
            Some(item.into_inner().next().unwrap().as_str().to_string())
        }
        _ => {}
      }
    }

    Ok(add_element_tag)
  }
}

impl PlantUMLSerializer for AddElementTag {
  fn serialize_to_plantuml(&self, level: usize) -> String {
    let mut params = String::new();

    // Serialize "tag"
    if let Some(tag) = &self.tag {
      params.push_str(&format!("\"{}\"", tag));
    }
    // Serialize "bg color"
    if let Some(bg_color) = &self.bg_color {
      params.push_str(&format!(", $bgColor=\"{}\"", bg_color));
    }
    // Serialize "font color"
    if let Some(font_color) = &self.font_color {
      params.push_str(&format!(", $fontColor=\"{}\"", font_color));
    }
    // Serialize "border color"
    if let Some(border_color) = &self.border_color {
      params.push_str(&format!(", $borderColor=\"{}\"", border_color));
    }
    // Serialize "shadowing"
    if let Some(shadowing) = &self.shadowing {
      params.push_str(&format!(", $shadowing=\"{}\"", shadowing));
    }
    // Serialize "shape"
    if let Some(shape) = &self.shape {
      params.push_str(&format!(", $shape={}", shape));
    }
    // Serialize "sprite"
    if let Some(sprite) = &self.sprite {
      params.push_str(&format!(", $sprite=\"{}\"", sprite));
    }
    // Serialize "techn"
    if let Some(techn) = &self.techn {
      params.push_str(&format!(", $techn=\"{}\"", techn));
    }
    // Serialize "legend text"
    if let Some(legend_text) = &self.legend_text {
      params.push_str(&format!(", $legendText=\"{}\"", legend_text));
    }
    // Serialize "legend sprite"
    if let Some(legend_sprite) = &self.legend_sprite {
      params.push_str(&format!(", $legendSprite=\"{}\"", legend_sprite));
    }
    // Serialize "border style"
    if let Some(border_style) = &self.border_style {
      params.push_str(&format!(", $borderStyle={}", border_style));
    }
    // Serialize "border thickness"
    if let Some(border_thickness) = &self.border_thickness {
      params.push_str(&format!(", $borderThickness=\"{}\"", border_thickness));
    }

    let add_elem_tag_ser = format!("AddElementTag({})", params);
    format_with_indent(level, add_elem_tag_ser)
  }
}
